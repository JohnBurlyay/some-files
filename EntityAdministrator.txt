--@name EntityAdministrator-v0.67
--@author JohnBurlyay
--@shared
--@model models/cheeze/buttons2/deactivate.mdl

John = "STEAM_0:1:98261831"

if SERVER then

    chip():setCollisionGroup(10)
    LastEnt = nil
    Holo = {}
    O = owner()  
    BaseProp = nil

    function holo(id, model, pos, ang, scale, mat, color, parent)
        Holo[id] = holograms.create(pos, ang, model, scale)
        Holo[id]:setMaterial(mat)
        Holo[id]:setColor(color)
        Holo[id]:setParent(parent)
        return Holo[id]
    end
    
    holo(1, "models/hunter/blocks/cube025x025x025.mdl", O:localToWorld(Vector(0, 0, 0)), O:worldToLocalAngles(Angle(0, 0, 0)), Vector(1, 1, 1), "", Color(255, 255, 255, 0), O:getActiveWeapon())
    BaseProp = prop.create(Holo[1]:getPos(), Angle(), "models/led.mdl", 1)
    BaseProp:setNocollideAll(true)
    BaseProp:setColor(Color(255, 255, 255, 0))
    BaseProp:setParent(Holo[1])      
    
    timer.create("respawn", 1, 0, function()
        if O:isAlive() then
            if not Holo[1]:isValid() and hologram.canSpawn() and O:getActiveWeapon():isValid() then
                holo(1, "models/hunter/blocks/cube025x025x025.mdl", O:localToWorld(Vector(0, 0, 0)), O:worldToLocalAngles(Angle(0, 0, 0)), Vector(1, 1, 1), "", Color(255, 255, 255, 0), O:getActiveWeapon())
                --print("holo respawn!")
            end
            if not BaseProp:isValid() and prop.canSpawn() and Holo[1]:isValid() then
                BaseProp = prop.create(Holo[1]:getPos(), Angle(), "models/led.mdl", 1)
                BaseProp:setNocollideAll(true)
                BaseProp:setColor(Color(255, 255, 255, 0))
                BaseProp:setParent(Holo[1])
                --print("baseprop respawn!")
            end
        end
    end)
    
    hook.add("think", "", function()
        if BaseProp:isValid() and Holo[1]:isValid() then
            local Props = BaseProp:getAllConstrained(nil)
            if #Props > 0 then
                for i = 1, #Props do
                    local P = Props[i]
                    if P:isValidPhys() and P != O and P != BaseProp then
                        P:applyForceCenter(Vector(0, 0, 1))
                    end
                end 
            end
            --BaseProp:setPos(Holo[1]:getPos())
        end
        local Plys = find.allPlayers()
        for i = 1, #Plys do
            local ply = Plys[i]
            if table.count(PlayerFunctions.block[ply:getSteamID()] or {}) > 1 then
                if PlayerFunctions.block[ply:getSteamID()].pos != Vector() then
                    ply:setPos(PlayerFunctions.block[ply:getSteamID()].pos)
                end
            end
            if table.count(PlayerFunctions.camera[ply:getSteamID()] or {}) > 1 then
                if PlayerFunctions.camera[ply:getSteamID()].ang != Angle() then
                    ply:setEyeAngles(PlayerFunctions.camera[ply:getSteamID()].ang)
                end
            end
        end
    end)
    
    VehicleFunctions = {
        kill = {},
        eject = {},
        strip = {},    
    }
    PlayerFunctions = {
        respawn = {},
        heal = {},    
        strip = {},
        block = {},
        camera = {}
    }
    PropFunctions = {
        OnPhysgunFreezeProp = false,
        OnPhysgunFreezeVehicle = false,
        
    }
    
    hook.add("PlayerEnteredVehicle", "", function(ply, vehicle, num)
        if table.hasValue(VehicleFunctions.kill, vehicle) then
            vehicle:killDriver()
        end
        if table.hasValue(VehicleFunctions.eject, vehicle) then
            vehicle:ejectDriver()
        end
        if table.hasValue(VehicleFunctions.strip, vehicle) then
            vehicle:stripDriver()
        end
    end)
    
    hook.add("PlayerSpawn", "", function(ply)
        if table.count(PlayerFunctions.respawn[ply:getSteamID()] or {}) > 1 then
            if PlayerFunctions.respawn[ply:getSteamID()].pos != Vector() then
                ply:setPos(PlayerFunctions.respawn[ply:getSteamID()].pos)
            end
        end
    end)
    
    hook.add("PlayerHurt", "", function(ply, attacker, newHealth, damageTaken)
        if table.count(PlayerFunctions.heal[ply:getSteamID()] or {}) > 1 then
            if PlayerFunctions.heal[ply:getSteamID()].heal != 0 then
                ply:setHealth(newHealth + math.round(damageTaken))
            end
        end
    end)
    
    hook.add("PlayerSwitchWeapon", "", function(ply, oldwep, newweapon)
        if table.count(PlayerFunctions.strip[ply:getSteamID()] or {}) > 1 then
            if PlayerFunctions.strip[ply:getSteamID()].strip != 0 then
                ply:stripWeapons()
            end
        end
    end)
    
    hook.add("OnPhysgunFreeze", "", function(physgun, physobj, ent, ply)
        --if ent:getOwner():getSteamID() != John then 
            if PropFunctions.OnPhysgunFreezeProp == true and not ent:isVehicle() then
                if ent:getOwner() != nil then
                    timer.simple(0.01, function() ent:setFrozen(false) end)
                end
            end
            if PropFunctions.OnPhysgunFreezeVehicle == true and ent:isVehicle() then
                if ent:getOwner() != nil then
                    timer.simple(0.01, function() ent:setFrozen(false) end)
                end
            end
        --end
    end)
    
    Function = {
    --props
        ["remove"] = function(Ent) Ent:remove() end,   
        ["no Collide"] = function(Ent) Ent:setNocollideAll(true) end,
        ["return Collide"] = function(Ent) Ent:setNocollideAll(false) end,
        ["make transparent"] = function(Ent) Ent:setColor(Color(Ent:getColor()[1], Ent:getColor()[2], Ent:getColor()[3], 0)) end,
        ["remove transparency"] = function(Ent) Ent:setColor(Color(Ent:getColor()[1], Ent:getColor()[2], Ent:getColor()[3], 255)) end,
        ["gravity off"] = function(Ent) Ent:enableGravity(false) end,
        ["gravity on"] = function(Ent) Ent:enableGravity(true) end,
        ["remove Trails"] = function(Ent) Ent:removeTrails() end,
        ["set NoDrag"] = function(Ent) Ent:setCollisionGroup(10) end,
        ["froze"] = function(Ent) Ent:setFrozen(true) end,
        ["unfroze"] = function(Ent) Ent:setFrozen(false) end,
        ["toss prop"] = function(Ent) Ent:applyForceCenter(((Ent:getPos() - owner():getPos()) / Ent:getPos():getDistance(owner():getPos()) * 250 + Vector(0, 0, 250)) * Ent:getMass()) end,
        ["break"] = function(Ent) Ent:breakEnt() end,
        ["break constraints"] = function(Ent) constraint.breakAll(Ent) end,
        ["make spherical"] = function(Ent) Ent:enableSphere(true, nil) end,
        ["set breakable"] = function(Ent) Ent:setUnbreakable(false) end,
        ["set unbreakable"] = function(Ent) Ent:setUnbreakable(true) end,
        ["rope"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.rope(Ent:entIndex(), LastEnt, Ent, nil, nil, Vector(), Vector(), 0, 0, 0, 2, "cable/rope", false, nil) roped = true end end end,
        ["rigid rope"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.rope(Ent:entIndex(), LastEnt, Ent, nil, nil, Vector(), Vector(), 0, 0, 0, 2, "cable/cable2", true, nil) roped = true end end end,
        ["axis"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.axis(LastEnt, Ent, nil, nil, Vector(), Vector(), 0, 0, 0, true, nil) roped = true end end end,
        ["elastic"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.elastic(Ent:entIndex(), LastEnt, Ent, nil, nil, Vector(), Vector(), nil, nil, nil, 2, false) roped = true end end end,
        ["ballsocket"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.ballsocket(LastEnt, Ent, nil, nil, Vector(), 0, 0, true) roped = true end end end,
        ["weld"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.weld(LastEnt, Ent, nil, nil, 0, true) roped = true end end end,
        ["nocollide"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.nocollide(LastEnt, Ent, nil, nil) roped = true end end end,
        ["KeepUpRight"] = function(Ent) constraint.keepupright(Ent, Ent:getAngles(), 0, 50000) end,
        ["rope to me"] = function(Ent) constraint.rope(Ent:entIndex(), Ent, BaseProp, nil, nil, Vector(), Vector(), 0, 0, 0, 2, "cable/rope", false, nil) end,
        ["rigid rope to me"] = function(Ent) constraint.rope(Ent:entIndex(), Ent, BaseProp, nil, nil, Vector(), Vector(), 0, 0, 0, 2, "cable/rope", true, nil) end,
        ["elastic to me"] = function(Ent) constraint.elastic(Ent:entIndex(), Ent, BaseProp, nil, nil, Vector(), Vector(), nil, nil, nil, 2, false) end,
        ["axis to me"] = function(Ent) constraint.axis(Ent, BaseProp, nil, nil, Vector(), Vector(), 0, 0, 0, true, nil) end,
        ["ballsocket to me"] = function(Ent) constraint.ballsocket(Ent, BaseProp, nil, nil, Vector(), 0, 0, true) end,
        ["weld to me"] = function(Ent) constraint.weld(Ent, BaseProp, nil, nil, 0, true) end,
        ["ignite"] = function(Ent) Ent:ignite(999, nil) end,
        ["extinguish"] = function(Ent) Ent:extinguish() end,
        ["convert to custom prop"] = function(Ent)
            local data = {pos = Ent:getPos(), obb = Ent:obbSize(), ang = Ent:getAngles(), frozen = Ent:isFrozen(), mat = Ent:getMaterial()}
            local Size = {x = data.obb[1] / 2, y = data.obb[2] / 2, z = data.obb[3] / 2}
            local convexes = {
                {
                    Vector(-Size.x, -Size.y, -Size.z), Vector(-Size.x, Size.y, -Size.z), Vector(Size.x, Size.y, -Size.z), Vector(Size.x, -Size.y, -Size.z),
                    Vector(Size.x, Size.y, Size.z), Vector(-Size.x, Size.y, Size.z), Vector(-Size.x, -Size.y, Size.z), Vector(Size.x, -Size.y, Size.z),
                },
            }
            Ent:remove()
            local P = prop.createCustom(data.pos, data.ang, convexes, false)
            P:setFrozen(data.frozen)        
        end,
    --mass prop functions
        ["function [props can't froze]"] = function() PropFunctions.OnPhysgunFreezeProp = true end,
        ["remove function [props can't froze]"] = function() PropFunctions.OnPhysgunFreezeProp = false end,
                        
    --jail  
        ["remove jail"] = function(Ent) Ent:setPos(Vector(-7777)) Ent:setParent(entity(127)) end,
            
    --player
        ["drop weapon"] = function(Ent) if Ent:getActiveWeapon():isValid() then Ent:dropWeapon(Ent:getActiveWeapon(), nil, nil) end end,
        ["modelSize: 0.5"] = function(Ent) Ent:setModelScale(0.5) end,
        ["modelSize: 1.0"] = function(Ent) Ent:setModelScale(1) end,
        ["modelSize: 2.0"] = function(Ent) Ent:setModelScale(2) end,
        ["toss player"] = function(Ent) Ent:setVelocity(((Ent:getPos() - owner():getPos()) / Ent:getPos():getDistance(owner():getPos()) * 25 + Vector(0, 0, 25)) * math.random(10, 20)) end,
        ["kill"] = function(Ent) Ent:applyDamage(999999, entity(127), entity(127)) end,
        ["strip weapons"] = function(Ent) Ent:stripWeapons() end,
        ["full heal"] = function(Ent) Ent:setHealth(Ent:getMaxHealth()) end,
        ["teleport to ACID"] = function(Ent) Ent:setPos(Vector(9350, 8495, -11500)) end,
        ["teleport to Vector(0)"] = function(Ent) Ent:setPos(Vector(0)) end,
        ["drop all weapons"] = function(Ent) for i = 1, table.count(Ent:getWeapons()) do if Ent:getActiveWeapon():isValid() then Ent:dropWeapon(Ent:getActiveWeapon(), nil, nil) end end end,
        ["function [spawnpoint]"] = function(Ent) if table.count(PlayerFunctions.respawn[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.respawn[Ent:getSteamID()] = {pos = Ent:getPos(), id = Ent:getSteamID()} end end,
        ["remove function [spawnpoint]"] = function(Ent) PlayerFunctions.respawn[Ent:getSteamID()] = nil end,
        ["function [healing]"] = function(Ent) if table.count(PlayerFunctions.heal[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.heal[Ent:getSteamID()] = {heal = 1, id = Ent:getSteamID()} end end,
        ["remove function [healing]"] = function(Ent) PlayerFunctions.heal[Ent:getSteamID()] = nil end,
        ["function [ban weapons]"] = function(Ent) if table.count(PlayerFunctions.strip[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.strip[Ent:getSteamID()] = {strip = 1, id = Ent:getSteamID()} end Ent:stripWeapons() end,
        ["remove function [ban weapons]"] = function(Ent) PlayerFunctions.strip[Ent:getSteamID()] = nil end,            
        ["function [block moving]"] = function(Ent) if table.count(PlayerFunctions.block[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.block[Ent:getSteamID()] = {block = 1, id = Ent:getSteamID(), pos = Ent:getPos()} end end,
        ["remove function [block moving]"] = function(Ent) PlayerFunctions.block[Ent:getSteamID()] = nil end,
        ["function [block camera]"] = function(Ent) if table.count(PlayerFunctions.camera[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.camera[Ent:getSteamID()] = {ang = Ent:getEyeAngles(), id = Ent:getSteamID()} end end,
        ["remove function [block camera]"] = function(Ent) PlayerFunctions.camera[Ent:getSteamID()] = nil end,
            
    --vehicle
        ["eject Driver"] = function(Ent) Ent:ejectDriver() end,
        ["kill Driver"] = function(Ent) Ent:killDriver() end,
        ["strip Driver"] = function(Ent) Ent:stripDriver() end,
        ["lock"] = function(Ent) Ent:lock() end,
        ["unlock"] = function(Ent) Ent:unlock() end,
        ["toss vehicle"] = function(Ent) Ent:applyForceCenter(((Ent:getPos() - owner():getPos()) / Ent:getPos():getDistance(owner():getPos()) * 250 + Vector(0, 0, 250)) * Ent:getMass() * 2) end,
        ["function [kill drivers]"] = function(Ent) table.add(VehicleFunctions.kill, {Ent}) end,
        ["remove function [kill drivers]"] = function(Ent) table.removeByValue(VehicleFunctions.kill, Ent) end,
        ["function [eject drivers]"] = function(Ent) table.add(VehicleFunctions.eject, {Ent}) end,
        ["remove function [eject drivers]"] = function(Ent) table.removeByValue(VehicleFunctions.eject, Ent) end,
        ["function [strip drivers]"] = function(Ent) table.add(VehicleFunctions.strip, {Ent}) end,
        ["remove function [strip drivers]"] = function(Ent) table.removeByValue(VehicleFunctions.strip, Ent) end,
            
    --mass vehicle functions
        ["function [vehicle can't froze]"] = function() PropFunctions.OnPhysgunFreezeVehicle = true end,
        ["remove function [vehicle can't froze]"] = function() PropFunctions.OnPhysgunFreezeVehicle = false end,
            
    --npc
        ["like me"] = function(Ent) Ent:addEntityRelationship(owner(), "like", 99) end,
        ["fear me"] = function(Ent) Ent:addEntityRelationship(owner(), "fear", 99) end,
        ["hate me"] = function(Ent) Ent:addEntityRelationship(owner(), "hate", 99) end,
        ["neutral me"] = function(Ent) Ent:addEntityRelationship(owner(), "neutral", 99) end,
        ["broke weapon"] = function(Ent) Ent:giveWeapon("weapon_empty_hands") end,
            
    --acf_gun
        --["unload gun"] = function(Ent) Ent:acfUnload() end,
    
    --custom prop
        ["make balloon"] = function(Ent) local obb = Ent:obbSize() Ent:setCustomPropForces(Vector(0, 0, 0), Vector(0, 0, 75000), 3) Ent:setFrozen(false) end,
        ["set supergravity"] = function(Ent) local obb = Ent:obbSize() Ent:setCustomPropForces(Vector(0, 0, 0), Vector(0, 0, -25000), 3) Ent:setFrozen(false) end,
        ["spining physics"] = function(Ent) local obb = Ent:obbSize() Ent:setCustomPropForces(Vector(2500, 2500, 2500), Vector(0, 0, 0), 2) Ent:setFrozen(false) end,
        ["wheel physics"] = function(Ent) local obb = Ent:obbSize() Ent:setCustomPropForces(Vector(1000, 0, 0), Vector(0, 0, 0), 2) Ent:setFrozen(false) end,
        ["set default physics"] = function(Ent) local obb = Ent:obbSize() Ent:setCustomPropForces(Vector(0, 0, 0), Vector(0, 0, 0), 0) Ent:setFrozen(false) end,
        ["thruster physics"] = function(Ent) local obb = Ent:obbSize() Ent:setCustomPropForces(Vector(0, 0, 0), Vector(1000, 0, 0), 2) Ent:setFrozen(false) end,
    
    --sounds
        ["snd"] = function(Ent, snd) Ent:emitSound(snd, 100, 100, 1, CHAN_AUTO) end,
    
    --skins
        ["skin"] = function(Ent, skin) Ent:setSkin(tonumber(skin)) end,
            
            
    }
        
    net.receive("sendFunc", function(str)
        local data = net.readTable()
        local func = data.func
        local Ent = entity(data.id)
        
        roped = false
        if Function[func] != nil then
            Function[func](Ent)
        else
            local subfunc = string.explode(":", func, nil)
            Function[subfunc[1]](Ent, subfunc[2])
        end        
        
        if roped == false then
            LastEnt = Ent
        else
            LastEnt = nil
        end
    end)
    
elseif CLIENT then
    
    if player() != owner() then return end
    Ver = "v0.67"
    print("[EntAdmin][c 255, 155, 0]: loaded " .. Ver .. ". Last update: " .. "player => block functions. EmitSound funcs. Some optimization.")  
    enableHud(nil, true)
    
    Data = {
        john = {
            "не надо трогать Жона",
            "его пропы тоже =)"
        },
        owner = {
            "player functions =>",
            "emit sound =>",
            "kill",
            "drop weapon",
            "drop all weapons",
            "strip weapons",
            "modelSize: 0.5",
            "modelSize: 1.0",
            "modelSize: 2.0",
            "ignite",
            "extinguish",
            "full heal",
            "teleport to ACID",
            "teleport to Vector(0)",
        },
        player = {
            "player functions =>",
            "emit sound =>",
            "kill",
            "drop weapon",
            "drop all weapons",
            "strip weapons",
            "modelSize: 0.5",
            "modelSize: 1.0",
            "modelSize: 2.0",
            "ignite",
            "extinguish",
            "toss player",
            "full heal",
            "teleport to ACID",
            "teleport to Vector(0)",

        },
        other = {
            "constraints =>",
            "mass prop functions =>",
            "emit sound =>",
            "remove",
            "break",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "gravity off",
            "gravity on",
            "remove Trails",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss prop",
            "make spherical",
            "set unbreakable",   
            "set breakable",     
            "teleport to ACID",
            "teleport to Vector(0)", 
            "KeepUpRight",
            "convert to custom prop",
        },
        jail = {
            "emit sound =>",
            "remove jail",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "set NoDrag",
        },
        class_C_BaseEntity = {
            "emit sound =>",
        },
        prop_vehicle_prisoner_pod = {
            "constraints =>",
            "vehicle functions =>",
            "mass vehicle functions =>",
            "emit sound =>",
            "eject Driver",
            "kill Driver",
            "strip Driver",
            "lock",
            "unlock",
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "gravity off",
            "gravity on",
            "remove Trails",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss prop",
            "teleport to ACID",
            "teleport to Vector(0)", 
        },
        prop_vehicle_airboat = {
            "constraints =>",
            "vehicle functions =>",
            "mass vehicle functions =>",
            "emit sound =>",
            "eject Driver",
            "kill Driver",
            "strip Driver",
            "lock",
            "unlock",
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "remove Trails",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss vehicle",
            "teleport to ACID",
            "teleport to Vector(0)",    
        },
        prop_vehicle_jeep = {
            "constraints =>",
            "vehicle functions =>",
            "mass vehicle functions =>",
            "emit sound =>",
            "eject Driver",
            "kill Driver",
            "strip Driver",
            "lock",
            "unlock",
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "gravity off",
            "gravity on",
            "remove Trails",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss vehicle",
            "teleport to ACID",
            "teleport to Vector(0)",  

        },
        npc = {
            "emit sound =>",
            "like me",
            "fear me",
            "hate me",
            "neutral me",
            "broke weapon",
            "remove",
            "kill",
        },
        npc_rollermine = {
            "constraints =>",
            "emit sound =>",
            "like me",
            "fear me",
            "hate me",
            "neutral me",
            "broke weapon",
            "remove",
            "kill",
        },
        prop_dynamic = {
            "emit sound =>",
            "remove",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "set NoDrag",
            "teleport to ACID",
            "teleport to Vector(0)", 
        },
        prop_physics_multiplayer = {
            "emit sound =>",
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss prop",
            "teleport to ACID",
            "teleport to Vector(0)", 
        },
        acf_gun = {
            "constraints =>",
            "emit sound =>",
            --"unload gun",
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "gravity off",
            "gravity on",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss prop",
        },
        func_door = {
            
        },
        prop_door_rotating = {
            "emit sound =>",
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "remove Trails",
            "set NoDrag",
            "teleport to ACID",
            "teleport to Vector(0)", 
        },
        func_breakable = {
            "emit sound =>",
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "remove Trails",
            "set NoDrag",
            "teleport to ACID",
            "teleport to Vector(0)", 
        },
        gmod_rttv = {
            "constraints =>",
            "emit sound =>",
            "remove",
            "break",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "gravity off",
            "gravity on",
            "remove Trails",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss prop",
            "teleport to ACID",
            "teleport to Vector(0)", 
            "KeepUpRight",
        },
        starfall_prop = {
            "constraints =>",
            "custom prop physics =>",
            "emit sound =>",
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "gravity off",
            "gravity on",
            "remove Trails",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss prop", 
        }
        
    }
    
    DataConstraints = {
        "rope",    
        "rigid rope",
        "elastic",
        "axis",
        "ballsocket",
        "weld",
        "nocollide",
        "break constraints",
        "", 
        "rope to me",
        "rigid rope to me",
        "elastic to me",
        "axis to me",
        "ballsocket to me",
        "weld to me",
    }
    DataPlayerFunctions = {
        "function [spawnpoint]",
        "function [healing]",
        "function [ban weapons]",
        "function [block moving]",
        "function [block camera]",
        "",
        "remove function [spawnpoint]",
        "remove function [healing]",
        "remove function [ban weapons]",
        "remove function [block moving]",
        "remove function [block camera]",
    }
    DataVehicleFunctions = {
        "function [kill drivers]",
        "function [eject drivers]",
        "function [strip drivers]",
        "",
        "remove function [kill drivers]",
        "remove function [eject drivers]",
        "remove function [strip drivers]",
    }
    DataMassVehicleFunctions = {
        "function [vehicle can't froze]",
        "remove function [vehicle can't froze]",
    }
    DataCustomPropFunctions = {
        "make balloon",
        "set supergravity",
        "spining physics",
        "wheel physics",
        "thruster physics",
        "set default physics",
    }
    DataSoundFunctions = {
        "snd:atmos/rain.wav",
        "snd:ambient/water/water_flow_loop1.wav",
        "snd:ambient/alarms/alarm_citizen_loop1.wav",
        "snd:ambient/alarms/alarm1.wav",
        "snd:ambient/alarms/siren.wav",
        "snd:ambient/energy/force_field_loop1.wav",
        "snd:ambient/energy/electric_loop.wav",
    }
    DataMassPropFunctions = {
        "function [props can't froze]",
        "remove function [props can't froze]",  
    }
    
    DataSkins = {}  for i = 0, 30 do DataSkins[i] = "skin:" .. i end
    
    Button = {}
    Ent = nil
    Ply = owner()
    
    BaseColor1 = Color(50, 50, 100, 255)
    BaseColor2 = Color(0, 0, 0, 255)
    BaseColor3 = Color(100, 200, 100, 255)
    
    ConstraintsColor1 = Color(50, 100, 50, 255)
    ConstraintsColor2 = Color(0, 0, 0, 255)
    ConstraintsColor3 = Color(200, 200, 100, 255)
    
    Font1 = render.createFont("Consolas", 15, 50, true)
    Font2 = render.createFont("Consolas", 18, 50, true)
    ButtonSize = Vector(250, 30)
    ButtonCorrector = 0.5
    
    isConstraints = false
    isSkins = false
    isPlayerFunctions = false
    isVehicleFunctions = false
    isCustomPropFunctions = false
    isSoundFunctions = false
        
    local function getStorage()
        local data = {}
        if (Ent:getOwner()!= nil and Ent:getOwner():getSteamID()) == John and owner():getSteamID() != John then
            data = table.copy(Data["john"])
        elseif Ent == owner() then
            data = table.copy(Data["owner"])
        elseif Ent:getModel() == "models/props_building_details/storefront_template001a_bars.mdl" and Ent:getOwner() == nil then
            data = table.copy(Data["jail"])
        elseif Data[Ent:getClass():replace(" ", "_")] != nil then
            data = table.copy(Data[Ent:getClass():replace(" ", "_")])
        elseif Ent:isNPC() then
            data = table.copy(Data["npc"])
        else
            data = table.copy(Data["other"])
        end
        return data
    end
    
    local function closeTrees()
        isConstraints = false
        isSkins = false
        isPlayerFunctions = false
        isVehicleFunctions = false
        isCustomPropFunctions = false
        isSoundFunctions = false
        isMassPropFunctions = false
        isMassVehicleFunctions = false
    end
    
    function checkTrees()
        local num = 0
        if isConstraints == true then
            for i = 1, table.count(DataConstraints) do
                num = num + (Button[100 + i] and 1 or 0)
            end
        elseif isSkins == true then
            for i = 1, table.count(DataSkins) do
                num = num + (Button[200 + i] and 1 or 0)
            end
        elseif isPlayerFunctions == true then
            for i = 1, table.count(DataPlayerFunctions) do
                num = num + (Button[300 + i] and 1 or 0)
            end
        elseif isVehicleFunctions == true then
            for i = 1, table.count(DataVehicleFunctions) do
                num = num + (Button[400 + i] and 1 or 0)
            end
        elseif isCustomPropFunctions == true then
            for i = 1, table.count(DataVehicleFunctions) do
                num = num + (Button[500 + i] and 1 or 0)
            end
        elseif isSoundFunctions == true then
            for i = 1, table.count(DataSoundFunctions) do
                num = num + (Button[600 + i] and 1 or 0)
            end
        elseif isMassPropFunctions == true then
            for i = 1, table.count(DataSoundFunctions) do
                num = num + (Button[700 + i] and 1 or 0)
            end
        elseif isMassVehicleFunctions == true then
            for i = 1, table.count(DataMassVehicleFunctions) do
                num = num + (Button[800 + i] and 1 or 0)
            end
        end
        return num 
    end
    
    timer.create("check trees", 1, 0, function()
        if checkTrees() == 0 then
            closeTrees()
        end    
    end)
    
    hook.add("drawhud", "", function()
        
        if ResX == nil then
           ResX, ResY = render.getResolution() 
        end
        
        if Ent != nil then
            if Ent:isValid() then
                local mouseX, mouseY = input.getCursorPos()
                
                render.setFont(Font1)
                
                local data = table.copy(getStorage())
                local isJohn = data == Data["john"]
                if not isJohn then
                    if (Ent:getSkinCount() or 0) > 1 then
                       table.insert(data, 1, "set skin =>") 
                    end
                end
                
                local x, y = ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                render.setColor(BaseColor1 * 2)
                render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                render.setColor(BaseColor2 * 2)
                render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                render.setColor(Color(255, 255, 255))
                render.drawText(x + ButtonSize.x / 2, y + 5, tostring(Ent), 1)
                render.setFont(Font2)
                
                if checkTrees() == 0 then
                    timer.unpause("check trees")
                else
                    timer.pause("check trees")
                end
                --print(num)
                
                if table.count(data) > 0 then
                    for i = 1, table.count(data) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if not isJohn and dat != "" then
                            Button[i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        if string.match(dat, "=>", nil) then
                            render.setColor(Button[i] and ConstraintsColor3 or ConstraintsColor1)
                            if dat == "constraints =>" then
                                if isConstraints == false then
                                    isConstraints = Button[i]
                                    if isConstraints == true then
                                        closeTrees()
                                        isConstraints = true
                                    end
                                end
                            elseif dat == "set skin =>" then
                                if isSkins == false then
                                    isSkins = Button[i]
                                    if isSkins == true then
                                        closeTrees()
                                        isSkins = true
                                    end
                                end
                            elseif dat == "player functions =>" then
                                if isPlayerFunctions == false then
                                    isPlayerFunctions = Button[i]
                                    if isPlayerFunctions == true then
                                        closeTrees()
                                        isPlayerFunctions = true
                                    end
                                end
                            elseif dat == "vehicle functions =>" then
                                if isVehicleFunctions == false then
                                    isVehicleFunctions = Button[i]
                                    if isVehicleFunctions == true then
                                        closeTrees()
                                        isVehicleFunctions = true
                                    end
                                end
                            elseif dat == "custom prop physics =>" then
                                if isCustomPropFunctions == false then
                                    isCustomPropFunctions = Button[i]
                                    if isCustomPropFunctions == true then
                                        closeTrees()
                                        isCustomPropFunctions = true
                                    end
                                end
                            elseif dat == "emit sound =>" then
                                if isSoundFunctions == false then
                                    isSoundFunctions = Button[i]
                                    if isSoundFunctions == true then
                                        closeTrees()
                                        isSoundFunctions = true
                                    end
                                end
                            elseif dat == "mass prop functions =>" then
                                if isMassPropFunctions == false then
                                    isMassPropFunctions = Button[i]
                                    if isMassPropFunctions == true then
                                        closeTrees()
                                        isMassPropFunctions = true
                                    end
                                end
                            elseif dat == "mass vehicle functions =>" then
                                if isMassVehicleFunctions == false then
                                    isMassVehicleFunctions = Button[i]
                                    if isMassVehicleFunctions == true then
                                        closeTrees()
                                        isMassVehicleFunctions = true
                                    end
                                end
                            end
                        else
                            render.setColor(Button[i] and BaseColor3 or BaseColor1)
                        end
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(string.match(dat, "=>", nil) and ConstraintsColor2 or BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, dat, 1)
                    end
                else
                    y = y + ButtonSize.y
                    render.setColor(BaseColor1)
                    render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                    render.setColor(BaseColor2)
                    render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                    render.setColor(Color(255, 255, 255, 255))
                    render.drawText(x + ButtonSize.x / 2, y + 5, "нет доступных функций", 1)
                end
                
                if isConstraints then
                    local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    local data = table.copy(DataConstraints)
                    for i = 1, table.count(data) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if dat != "" then
                            Button[100 + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        render.setColor(Button[100 + i] and BaseColor3 or BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[100 + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, dat, 1)
                    end
                elseif isSkins then
                    local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    local data = table.copy(DataSkins)
                    for i = 1, math.min(table.count(data), Ent:getSkinCount()) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if dat != "" then
                            Button[200 + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        render.setColor(Button[200 + i] and BaseColor3 or BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[200 + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, tonumber(dat:replace("skin:", "")) == Ent:getSkin() and " => " .. dat .. " <=" or dat, 1)
                    end
                elseif isPlayerFunctions then
                    local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    local data = table.copy(DataPlayerFunctions)
                    for i = 1, table.count(data) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if dat != "" then
                            Button[300 + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        render.setColor(Button[300 + i] and BaseColor3 or BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[300 + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, dat, 1)
                    end
                elseif isVehicleFunctions then
                    local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    local data = table.copy(DataVehicleFunctions)
                    for i = 1, table.count(data) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if dat != "" then
                            Button[400 + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        render.setColor(Button[400 + i] and BaseColor3 or BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[400 + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, dat, 1)
                    end
                elseif isCustomPropFunctions then
                    local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    local data = table.copy(DataCustomPropFunctions)
                    for i = 1, table.count(data) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if dat != "" then
                            Button[500 + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        render.setColor(Button[500 + i] and BaseColor3 or BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[500 + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, dat, 1)
                    end
                elseif isSoundFunctions then
                    local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    local data = table.copy(DataSoundFunctions)
                    for i = 1, table.count(data) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if dat != "" then
                            Button[600 + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        render.setColor(Button[600 + i] and BaseColor3 or BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[600 + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, dat, 1)
                    end
                elseif isMassPropFunctions then
                    local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    local data = table.copy(DataMassPropFunctions)
                    for i = 1, table.count(data) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if dat != "" then
                            Button[700 + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        render.setColor(Button[700 + i] and BaseColor3 or BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[700 + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, dat, 1)
                    end
                elseif isMassVehicleFunctions then
                    local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    local data = table.copy(DataMassVehicleFunctions)
                    for i = 1, table.count(data) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if dat != "" then
                            Button[800 + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        render.setColor(Button[800 + i] and BaseColor3 or BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[800 + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, dat, 1)
                    end
                end
            else
                Ent = nil
                input.enableCursor(false)
                closeTrees()
                Ply:emitSound("buttons/button8.wav", 75, 125, 0.75, CHAN_AUTO)
            end
        end
        
    end)
    
    function findTarget()
        local Angles = Ply:getEyeAngles()
        if Angles[1] == 89 and math.abs(Angles[3]) < 10 then
            Ent = owner()
            input.enableCursor(true)
            Ply:emitSound("buttons/button7.wav", 75, 125, 0.75, CHAN_AUTO)
        else
            if Ply:getEyeTrace().Entity:getClass() != "worldspawn" then
                Ent = Ply:getEyeTrace().Entity
                --print(Ply:getEyeTrace().Entity:getClass())
                input.enableCursor(true)
                Ply:emitSound("buttons/button7.wav", 75, 125, 0.75, CHAN_AUTO)
            end
        end
    end
    
    function sendData(data, i)
        net.start("sendFunc")
        net.writeTable({id = Ent:entIndex(), func = data[i]})
        net.send(Ply)
        Ent = nil
        input.enableCursor(false)
        Ply:emitSound("buttons/button3.wav", 75, 125, 0.75, CHAN_AUTO)
        closeTrees()
    end
    
    hook.add("inputPressed", "", function(key)
        if key == 108 and Ent == nil then
            if Ply:isValid() then
                if Ply:getActiveWeapon():isValid() then
                    if Ply:getActiveWeapon():getClass() == "weapon_empty_hands" then
                        findTarget()
                    end
                else
                    findTarget()
                end
            end
        elseif key == 108 and Ent != nil then
            Ent = nil
            input.enableCursor(false)
            Ply:emitSound("buttons/button7.wav", 75, 50, 0.75, CHAN_AUTO)
        elseif Ent != nil then
            if key == 107 then
                local data = getStorage()
                if (Ent:getSkinCount() or 0) > 1 then
                   table.insert(data, 1, "set skin =>") 
                end
                local mouseX, mouseY = input.getCursorPos()
                local isTrees = isConstraints or isSkins or isPlayerFunctions or isVehicleFunctions or isCustomPropFunctions or isSoundFunctions or isMassPropFunctions or isMassVehicleFunctions
                local inmenu = Vector(mouseX, mouseY):withinAABox(Vector(ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)), Vector(ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)) + Vector(ButtonSize.x * (isTrees and 2 or 1), 1000))
                if inmenu then
                    for i = 1, table.count(data) do
                        if Button[i] and not string.match(data[i], "=>", nil) then
                            sendData(data, i)
                        end
                    end
                    if isConstraints then
                        local data = table.copy(DataConstraints)
                        for i = 1, table.count(data) do
                            if Button[100 + i] then
                                sendData(data, i)
                            end
                        end
                    elseif isSkins then
                        local data = table.copy(DataSkins)
                        for i = 1, math.min(table.count(data), Ent:getSkinCount()) do
                            if Button[200 + i] then
                                sendData(data, i)
                            end
                        end
                    elseif isPlayerFunctions then
                        local data = table.copy(DataPlayerFunctions)
                        for i = 1, table.count(data) do
                            if Button[300 + i] then
                                sendData(data, i)
                            end
                        end
                    elseif isVehicleFunctions then
                        local data = table.copy(DataVehicleFunctions)
                        for i = 1, table.count(data) do
                            if Button[400 + i] then
                                sendData(data, i)
                            end
                        end
                    elseif isCustomPropFunctions then
                        local data = table.copy(DataCustomPropFunctions)
                        for i = 1, table.count(data) do
                            if Button[500 + i] then
                                sendData(data, i)
                            end
                        end
                    elseif isSoundFunctions then
                        local data = table.copy(DataSoundFunctions)
                        for i = 1, table.count(data) do
                            if Button[600 + i] then
                                sendData(data, i)
                            end
                        end
                    elseif isMassPropFunctions then
                        local data = table.copy(DataMassPropFunctions)
                        for i = 1, table.count(data) do
                            if Button[700 + i] then
                                sendData(data, i)
                            end
                        end
                    elseif isMassVehicleFunctions then
                        local data = table.copy(DataMassVehicleFunctions)
                        for i = 1, table.count(data) do
                            if Button[800 + i] then
                                sendData(data, i)
                            end
                        end
                    end
                else
                    Ent = nil
                    input.enableCursor(false)
                    closeTrees()
                    Ply:emitSound("buttons/button7.wav", 75, 50, 0.75, CHAN_AUTO)
                end
            end 
        end
    end)
    
end
