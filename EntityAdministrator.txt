--@name EntityAdministrator-v0.78
--@author JohnBurlyay
--@shared
--@model models/cheeze/buttons2/deactivate.mdl

John = "STEAM_0:1:98261831"

if SERVER then
    
    wire.adjustOutputs({"Grab"}, {"number"})
    wire.ports.Grab = 0
    
    chip():setCollisionGroup(10)
    LastEnt = nil
    Holo = {}
    O = owner()  
    BaseProp = nil
    GraberEntity = nil
    Grabed = nil

    function holo(id, model, pos, ang, scale, mat, color, parent)
        Holo[id] = holograms.create(pos, ang, model, scale)
        Holo[id]:setMaterial(mat)
        Holo[id]:setColor(color)
        Holo[id]:setParent(parent)
        return Holo[id]
    end
    
    holo(1, "models/hunter/blocks/cube025x025x025.mdl", O:localToWorld(Vector(0, 0, 0)), O:worldToLocalAngles(Angle(0, 0, 0)), Vector(1, 1, 1), "", Color(255, 255, 255, 0), O:getActiveWeapon())
    BaseProp = prop.create(Holo[1]:getPos(), Angle(), "models/led.mdl", 1)
    BaseProp:setNocollideAll(true)
    BaseProp:setColor(Color(255, 255, 255, 0))
    BaseProp:setParent(Holo[1])      
    
    local function Graber(Ent)
        if GraberEntity != nil or Ent == nil then
            if GraberEntity:isValid() then
                GraberEntity:remove()
                wire.ports.Grab = 0
                GraberEntity = nil
                if Grabed:isValid() then
                    Grabed:enableGravity(true) 
                end
                Grabed = nil
            end
        else
            Grabed = Ent
            local pos = owner():localToWorld(Vector(0, 0, 40)) + (Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 3)) - owner():localToWorld(Vector(0, 0, 40))) * 0.25
            local ang = (Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 3)) - pos):getAngle() + Angle(90, 0, 0)
            GraberEntity = prop.createSent(pos, ang, "gmod_wire_grabber", 1, {Gravity = true, Model = "models/hunter/plates/plate.mdl", Range = 10000})
            GraberEntity:setNocollideAll(true)
            GraberEntity:setColor(Color(255, 255, 255, 0))
            wire.ports.Grab = 1
            Ent:setFrozen(false)
            timer.simple(0.1, function() wire.create(GraberEntity, chip(), "Grab", "Grab") end)
            timer.simple(0.25, function() GraberEntity["enable"] = 1 end)
        end
    end
    
    timer.create("respawn", 1, 0, function()
        if O:isAlive() then
            if not Holo[1]:isValid() and hologram.canSpawn() and O:getActiveWeapon():isValid() then
                holo(1, "models/hunter/blocks/cube025x025x025.mdl", O:localToWorld(Vector(0, 0, 0)), O:worldToLocalAngles(Angle(0, 0, 0)), Vector(1, 1, 1), "", Color(255, 255, 255, 0), O:getActiveWeapon())
            end
            if not BaseProp:isValid() and prop.canSpawn() and Holo[1]:isValid() then
                BaseProp = prop.create(Holo[1]:getPos(), Angle(), "models/led.mdl", 1)
                BaseProp:setNocollideAll(true)
                BaseProp:setColor(Color(255, 255, 255, 0))
                BaseProp:setParent(Holo[1])
            end
        end
    end)
    
    hook.add("tick", "", function()
        if BaseProp:isValid() and Holo[1]:isValid() then
            local Props = BaseProp:getAllConstrained(nil)
            if #Props > 0 then
                for i = 1, #Props do
                    local P = Props[i]
                    if P:isValidPhys() and P != O and P != BaseProp then
                        P:applyForceCenter(Vector(0, 0, 1))
                    end
                end 
            end
        end
        local Plys = find.allPlayers()
        for i = 1, #Plys do
            local ply = Plys[i]
            if table.count(PlayerFunctions.block[ply:getSteamID()] or {}) > 1 then
                if PlayerFunctions.block[ply:getSteamID()].pos != Vector() then
                    ply:setPos(PlayerFunctions.block[ply:getSteamID()].pos)
                end
            end
            if table.count(PlayerFunctions.camera[ply:getSteamID()] or {}) > 1 then
                if PlayerFunctions.camera[ply:getSteamID()].ang != Angle() then
                    ply:setEyeAngles(PlayerFunctions.camera[ply:getSteamID()].ang)
                end
            end
        end
        --graber work
        if GraberEntity != nil and GraberEntity:isValid() then
            if GraberEntity["enable"] == 1 then
                GraberEntity:setPos(owner():localToWorld(Vector(0, 0, 40)))
                GraberEntity:setAngles(owner():getEyeAngles() + Angle(90, 0, 0))
            end
            if Grabed:isValid() and Grabed:isValidPhys() then
               Grabed:setFrozen(false) 
            end
        end
    end)
    
    VehicleFunctions = {
        kill = {},
        eject = {},
        strip = {},    
    }
    PlayerFunctions = {
        respawn = {},
        heal = {},    
        strip = {},
        block = {},
        camera = {},
        propspawn = {},
        npcspawn = {},
        altenter = {}
    }
    PropFunctions = {
        OnPhysgunFreezeProp = false,
        OnPhysgunFreezeVehicle = false,
        
    }
    RemoteUse = {}
    
    hook.add("PlayerEnteredVehicle", "", function(ply, vehicle, num)
        if table.hasValue(VehicleFunctions.kill, vehicle) then
            vehicle:killDriver()
        end
        if table.hasValue(VehicleFunctions.eject, vehicle) then
            vehicle:ejectDriver()
        end
        if table.hasValue(VehicleFunctions.strip, vehicle) then
            vehicle:stripDriver()
        end
        
        if table.count(PlayerFunctions.altenter[ply:getSteamID()] or {}) > 1 and vehicle:getCollisionGroup() == 20 then
            vehicle:ejectDriver()
        end
        
        --print(ply, vehicle)
    end)
    
    hook.add("PlayerSpawn", "", function(ply)
        if table.count(PlayerFunctions.respawn[ply:getSteamID()] or {}) > 1 then
            if PlayerFunctions.respawn[ply:getSteamID()].pos != Vector() then
                ply:setPos(PlayerFunctions.respawn[ply:getSteamID()].pos)
            end
        end
    end)
    
    hook.add("PlayerHurt", "", function(ply, attacker, newHealth, damageTaken)
        if table.count(PlayerFunctions.heal[ply:getSteamID()] or {}) > 1 then
            if PlayerFunctions.heal[ply:getSteamID()].heal != 0 then
                ply:setHealth(newHealth + math.round(damageTaken))
            end
        end
    end)
    
    hook.add("PlayerSwitchWeapon", "", function(ply, oldwep, newweapon)
        if table.count(PlayerFunctions.strip[ply:getSteamID()] or {}) > 1 then
            if PlayerFunctions.strip[ply:getSteamID()].strip != 0 then
                ply:stripWeapons()
            end
        end
        
        if ply == owner() and GraberEntity != nil then
            Graber(nil)
        end
    end)
    
    hook.add("OnPhysgunFreeze", "", function(physgun, physobj, ent, ply)
        --if ent:getOwner():getSteamID() != John then 
            if PropFunctions.OnPhysgunFreezeProp == true and not ent:isVehicle() then
                if ent:getOwner() != nil then
                    timer.simple(0.01, function() ent:setFrozen(false) end)
                end
            end
            if PropFunctions.OnPhysgunFreezeVehicle == true and ent:isVehicle() then
                if ent:getOwner() != nil then
                    timer.simple(0.01, function() ent:setFrozen(false) end)
                end
            end
        --end
    end)
    
    hook.add("OnEntityCreated", "", function(ent)
        if ent:isValid() then
            if ent:getOwner() != nil then
                local ply = ent:getOwner()
                if ent:isNPC() then
                    if table.count(PlayerFunctions.npcspawn[ply:getSteamID()] or {}) > 1 then
                        ent:remove()
                    end
                elseif ent:getClass() == "prop_physics" then 
                    if table.count(PlayerFunctions.propspawn[ply:getSteamID()] or {}) > 1 then
                        ent:remove()
                    end
                end
            end
        end
    end)
        
    Function = {
    --props
        ["remove"] = function(Ent) Ent:remove() end,   
        ["no Collide"] = function(Ent) Ent:setNocollideAll(true) end,
        ["return Collide"] = function(Ent) Ent:setNocollideAll(false) end,
        ["make transparent"] = function(Ent) Ent:setColor(Color(Ent:getColor()[1], Ent:getColor()[2], Ent:getColor()[3], 0)) end,
        ["remove transparency"] = function(Ent) Ent:setColor(Color(Ent:getColor()[1], Ent:getColor()[2], Ent:getColor()[3], 255)) end,
        ["gravity off"] = function(Ent) Ent:enableGravity(false) end,
        ["gravity on"] = function(Ent) Ent:enableGravity(true) end,
        ["remove Trails"] = function(Ent) Ent:removeTrails() end,
        ["set NoDrag"] = function(Ent) Ent:setCollisionGroup(10) end,
        ["froze"] = function(Ent) Ent:setFrozen(true) end,
        ["unfroze"] = function(Ent) Ent:setFrozen(false) end,
        ["toss prop"] = function(Ent) Ent:applyForceCenter(((Ent:getPos() - owner():getPos()) / Ent:getPos():getDistance(owner():getPos()) * 250 + Vector(0, 0, 250)) * Ent:getMass()) end,
        ["break"] = function(Ent) Ent:breakEnt() end,
        ["break constraints"] = function(Ent) constraint.breakAll(Ent) end,
        ["make spherical"] = function(Ent) Ent:enableSphere(true, nil) end,
        ["set breakable"] = function(Ent) Ent:setUnbreakable(false) end,
        ["set unbreakable"] = function(Ent) Ent:setUnbreakable(true) end,
        ["rope"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.rope(Ent:entIndex(), LastEnt, Ent, nil, nil, Vector(), Vector(), 0, 0, 0, 2, "cable/rope", false, nil) roped = true end end end,
        ["rigid rope"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.rope(Ent:entIndex(), LastEnt, Ent, nil, nil, Vector(), Vector(), 0, 0, 0, 2, "cable/cable2", true, nil) roped = true end end end,
        ["axis"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.axis(LastEnt, Ent, nil, nil, Vector(), Vector(), 0, 0, 0, true, nil) roped = true end end end,
        ["elastic"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.elastic(Ent:entIndex(), LastEnt, Ent, nil, nil, Vector(), Vector(), nil, nil, nil, 2, false) roped = true end end end,
        ["ballsocket"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.ballsocket(LastEnt, Ent, nil, nil, Vector(), 0, 0, true) roped = true end end end,
        ["weld"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.weld(LastEnt, Ent, nil, nil, 0, true) roped = true end end end,
        ["nocollide"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.nocollide(LastEnt, Ent, nil, nil) roped = true end end end,
        ["KeepUpRight"] = function(Ent) constraint.keepupright(Ent, Ent:getAngles(), 0, 50000) end,
        ["rope to me"] = function(Ent) constraint.rope(Ent:entIndex(), Ent, BaseProp, nil, nil, Vector(), Vector(), 0, 0, 0, 2, "cable/rope", false, nil) end,
        ["rigid rope to me"] = function(Ent) constraint.rope(Ent:entIndex(), Ent, BaseProp, nil, nil, Vector(), Vector(), 0, 0, 0, 2, "cable/rope", true, nil) end,
        ["elastic to me"] = function(Ent) constraint.elastic(Ent:entIndex(), Ent, BaseProp, nil, nil, Vector(), Vector(), nil, nil, nil, 2, false) end,
        ["axis to me"] = function(Ent) constraint.axis(Ent, BaseProp, nil, nil, Vector(), Vector(), 0, 0, 0, true, nil) end,
        ["ballsocket to me"] = function(Ent) constraint.ballsocket(Ent, BaseProp, nil, nil, Vector(), 0, 0, true) end,
        ["weld to me"] = function(Ent) constraint.weld(Ent, BaseProp, nil, nil, 0, true) end,
        ["ignite"] = function(Ent) Ent:ignite(999, nil) end,
        ["extinguish"] = function(Ent) Ent:extinguish() end,
        ["convert to custom prop"] = function(Ent)
            local data = {pos = Ent:getPos(), obb = Ent:obbSize(), ang = Ent:getAngles(), frozen = Ent:isFrozen(), mat = Ent:getMaterial()}
            local Size = {x = data.obb[1] / 2, y = data.obb[2] / 2, z = data.obb[3] / 2}
            local convexes = {
                {
                    Vector(-Size.x, -Size.y, -Size.z), Vector(-Size.x, Size.y, -Size.z), Vector(Size.x, Size.y, -Size.z), Vector(Size.x, -Size.y, -Size.z),
                    Vector(Size.x, Size.y, Size.z), Vector(-Size.x, Size.y, Size.z), Vector(-Size.x, -Size.y, Size.z), Vector(Size.x, -Size.y, Size.z),
                },
            }
            local mat = Ent:getMaterials()
            local P = prop.createCustom(data.pos, data.ang, convexes, false)
            P:setFrozen(data.frozen) 
            Ent:remove()
            net.start("CustomProp+Material")
            net.writeTable({entID = P:entIndex(), mat = mat})
            net.send() 
        end,
        
        ["grab / stop grab"] = function(Ent) Graber(Ent) end,
        ["add/remove dissolving"] = function(Ent) local Phys = Ent:getPhysicsObject() if Phys:hasGameFlags(FVPHYSICS.DMG_DISSOLVE) then Phys:clearGameFlags(FVPHYSICS.DMG_DISSOLVE) else Phys:addGameFlags(FVPHYSICS.DMG_DISSOLVE) end end,
        
    --mass prop functions
        ["function [props can't froze]"] = function() PropFunctions.OnPhysgunFreezeProp = true end,
        ["remove function [props can't froze]"] = function() PropFunctions.OnPhysgunFreezeProp = false end,
                        
    --jail  
        ["remove jail"] = function(Ent) Ent:setPos(Vector(-7777)) Ent:setParent(entity(127)) end,
            
    --player
        ["drop weapon"] = function(Ent) if Ent:getActiveWeapon():isValid() then Ent:dropWeapon(Ent:getActiveWeapon(), nil, nil) end end,
        ["modelSize: 0.5"] = function(Ent) Ent:setModelScale(0.5) end,
        ["modelSize: 1.0"] = function(Ent) Ent:setModelScale(1) end,
        ["modelSize: 2.0"] = function(Ent) Ent:setModelScale(2) end,
        ["toss player"] = function(Ent) Ent:setVelocity(((Ent:getPos() - owner():getPos()) / Ent:getPos():getDistance(owner():getPos()) * 25 + Vector(0, 0, 25)) * math.random(10, 20)) end,
        ["kill"] = function(Ent) Ent:applyDamage(999999, entity(127), entity(127)) end,
        ["strip weapons"] = function(Ent) Ent:stripWeapons() end,
        ["full heal"] = function(Ent) Ent:setHealth(Ent:getMaxHealth()) end,
        ["teleport to ACID"] = function(Ent) Ent:setPos(Vector(9350, 8495, -11500)) end,
        ["teleport to Vector(0)"] = function(Ent) Ent:setPos(Vector(0)) end,
        ["drop all weapons"] = function(Ent) for i = 1, table.count(Ent:getWeapons()) do if Ent:getActiveWeapon():isValid() then Ent:dropWeapon(Ent:getActiveWeapon(), nil, nil) end end end,
        ["toss me"] = function(Ent) Ent:setVelocity(Vector(Ent:getVelocity()[1] * 0.75, Ent:getVelocity()[2] * 0.75, math.abs(Ent:getVelocity()[3]) + 400)) end,
        
        
        ["function [spawnpoint]"] = function(Ent) if table.count(PlayerFunctions.respawn[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.respawn[Ent:getSteamID()] = {pos = Ent:getPos(), id = Ent:getSteamID()} end end,
        ["remove function [spawnpoint]"] = function(Ent) PlayerFunctions.respawn[Ent:getSteamID()] = nil end,
        ["function [healing]"] = function(Ent) if table.count(PlayerFunctions.heal[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.heal[Ent:getSteamID()] = {heal = 1, id = Ent:getSteamID()} end end,
        ["remove function [healing]"] = function(Ent) PlayerFunctions.heal[Ent:getSteamID()] = nil end,
        ["function [ban weapons]"] = function(Ent) if table.count(PlayerFunctions.strip[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.strip[Ent:getSteamID()] = {strip = 1, id = Ent:getSteamID()} end Ent:stripWeapons() end,
        ["remove function [ban weapons]"] = function(Ent) PlayerFunctions.strip[Ent:getSteamID()] = nil end,            
        ["function [block moving]"] = function(Ent) if table.count(PlayerFunctions.block[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.block[Ent:getSteamID()] = {block = 1, id = Ent:getSteamID(), pos = Ent:getPos()} end end,
        ["remove function [block moving]"] = function(Ent) PlayerFunctions.block[Ent:getSteamID()] = nil end,
        ["function [block camera]"] = function(Ent) if table.count(PlayerFunctions.camera[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.camera[Ent:getSteamID()] = {ang = Ent:getEyeAngles(), id = Ent:getSteamID()} end end,
        ["remove function [block camera]"] = function(Ent) PlayerFunctions.camera[Ent:getSteamID()] = nil end,
        ["function [block PROPspawn]"] = function(Ent) if table.count(PlayerFunctions.propspawn[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.propspawn[Ent:getSteamID()] = {id = Ent:getSteamID(), propspawn = 1} end end,
        ["remove function [block PROPspawn]"] = function(Ent) PlayerFunctions.propspawn[Ent:getSteamID()] = nil end,
        ["function [block NPCspawn]"] = function(Ent) if table.count(PlayerFunctions.npcspawn[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.npcspawn[Ent:getSteamID()] = {id = Ent:getSteamID(), npcspawn = 1} end end,
        ["remove function [block NPCspawn]"] = function(Ent) PlayerFunctions.npcspawn[Ent:getSteamID()] = nil end,
        ["function [block Alt+E]"] = function(Ent) if table.count(PlayerFunctions.altenter[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.altenter[Ent:getSteamID()] = {id = Ent:getSteamID(), altenter = 1} end end,
        ["remove function [block Alt+E]"] = function(Ent) PlayerFunctions.altenter[Ent:getSteamID()] = nil end,
         
            
    --vehicle
        ["eject Driver"] = function(Ent) Ent:ejectDriver() end,
        ["kill Driver"] = function(Ent) Ent:killDriver() end,
        ["strip Driver"] = function(Ent) Ent:stripDriver() end,
        ["lock"] = function(Ent) Ent:lock() end,
        ["unlock"] = function(Ent) Ent:unlock() end,
        ["toss vehicle"] = function(Ent) Ent:applyForceCenter(((Ent:getPos() - owner():getPos()) / Ent:getPos():getDistance(owner():getPos()) * 250 + Vector(0, 0, 250)) * Ent:getMass() * 2) end,
        ["function [kill drivers]"] = function(Ent) table.add(VehicleFunctions.kill, {Ent}) end,
        ["remove function [kill drivers]"] = function(Ent) table.removeByValue(VehicleFunctions.kill, Ent) end,
        ["function [eject drivers]"] = function(Ent) table.add(VehicleFunctions.eject, {Ent}) end,
        ["remove function [eject drivers]"] = function(Ent) table.removeByValue(VehicleFunctions.eject, Ent) end,
        ["function [strip drivers]"] = function(Ent) table.add(VehicleFunctions.strip, {Ent}) end,
        ["remove function [strip drivers]"] = function(Ent) table.removeByValue(VehicleFunctions.strip, Ent) end,
            
    --mass vehicle functions
        ["function [vehicle can't froze]"] = function() PropFunctions.OnPhysgunFreezeVehicle = true end,
        ["remove function [vehicle can't froze]"] = function() PropFunctions.OnPhysgunFreezeVehicle = false end,
            
    --npc
        ["like me"] = function(Ent) Ent:addEntityRelationship(owner(), "like", 99) end,
        ["fear me"] = function(Ent) Ent:addEntityRelationship(owner(), "fear", 99) end,
        ["hate me"] = function(Ent) Ent:addEntityRelationship(owner(), "hate", 99) end,
        ["neutral me"] = function(Ent) Ent:addEntityRelationship(owner(), "neutral", 99) end,
        ["broke weapon"] = function(Ent) Ent:giveWeapon("weapon_empty_hands") end,
            
    --acf_gun
        --["unload gun"] = function(Ent) Ent:acfUnload() end,
    
    --custom prop
        ["make balloon"] = function(Ent, func) local obb = Ent:obbSize() Ent:setCustomPropForces(Vector(0, 0, 0), Vector(0, 0, 75000), 3) Ent:setFrozen(false) Ent["forces"] = func end,
        ["set supergravity"] = function(Ent, func) local obb = Ent:obbSize() Ent:setCustomPropForces(Vector(0, 0, 0), Vector(0, 0, -25000), 3) Ent:setFrozen(false) Ent["forces"] = func end,
        ["spining physics"] = function(Ent, func) local obb = Ent:obbSize() Ent:setCustomPropForces(Vector(2500, 2500, 2500), Vector(0, 0, 0), 2) Ent:setFrozen(false) Ent["forces"] = func end,
        ["wheel physics"] = function(Ent, func) local obb = Ent:obbSize() Ent:setCustomPropForces(Vector(1000, 0, 0), Vector(0, 0, 0), 2) Ent:setFrozen(false) Ent["forces"] = func end,
        ["set default physics"] = function(Ent, func) local obb = Ent:obbSize() Ent:setCustomPropForces(Vector(0, 0, 0), Vector(0, 0, 0), 0) Ent:setFrozen(false) Ent["forces"] = "" end,
        ["thruster physics"] = function(Ent, func) local obb = Ent:obbSize() Ent:setCustomPropForces(Vector(0, 0, 0), Vector(1000, 0, 0), 2) Ent:setFrozen(false) Ent["forces"] = func end,
    
    --sounds
        ["loop"] = function(Ent, snd) Ent:emitSound(snd, 100, 100, 1, CHAN_AUTO) end,
    
    --skins
        ["skin"] = function(Ent, skin) Ent:setSkin(tonumber(skin - 1)) end,
            
    --remote use
        ["remote"] = function(Ent, key) RemoteUse[key] = Ent net.start("RemoteUseData") net.writeTable(RemoteUse) net.send(owner()) end,
        ["clear all buttons"] = function(Ent) RemoteUse = {} net.start("RemoteUseData") net.writeTable(RemoteUse) net.send(owner()) end,
        ["use"] = function(Ent) owner():setPos(Ent:localToWorld(Ent:isVehicle() and Vector(30, 30, 0) or Vector())) Ent:use() end,
    
    --effects
        ["large light"] = function(Ent) 
            if Ent["effects"] == nil then Ent["effects"] = {} end
            local effect_scale = (Ent:obbSize().x + Ent:obbSize().y + Ent:obbSize().z) / 5 effect_scale = math.min(effect_scale, 100)
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(-90, 0, 0), "gmod_emitter", 1, {delay = 0, effect = "ar2explosion", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(90, 0, 0), "gmod_emitter", 1, {delay = 0, effect = "ar2explosion", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
        end,
        ["explosion"] = function(Ent) 
            if Ent["effects"] == nil then Ent["effects"] = {} end
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(-90, 0, 0), "gmod_emitter", 1, {delay = 0.25, effect = "explosion", key = 1, Model = "models/props_lab/tpplug.mdl", scale = 1, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
        end,
        ["blood"] = function(Ent) 
            if Ent["effects"] == nil then Ent["effects"] = {} end
            local effect_scale = (Ent:obbSize().x + Ent:obbSize().y + Ent:obbSize().z) / 10 effect_scale = math.min(effect_scale, 15)
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(-90, 0, 0), "gmod_emitter", 1, {delay = 0.1, effect = "bloodspray", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(90, 0, 0), "gmod_emitter", 1, {delay = 0.1, effect = "bloodspray", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
        end,
        ["strider blood"] = function(Ent) 
            if Ent["effects"] == nil then Ent["effects"] = {} end
            local effect_scale = (Ent:obbSize().x + Ent:obbSize().y + Ent:obbSize().z) / 10 effect_scale = math.min(effect_scale, 15)
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(-90, 0, 0), "gmod_emitter", 1, {delay = 0.1, effect = "striderblood", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(90, 0, 0), "gmod_emitter", 1, {delay = 0.1, effect = "striderblood", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
        end,
        ["cball explosion"] = function(Ent) 
            if Ent["effects"] == nil then Ent["effects"] = {} end
            local effect_scale = (Ent:obbSize().x + Ent:obbSize().y + Ent:obbSize().z) / 5 effect_scale = math.min(effect_scale, 100)
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(-90, 0, 0), "gmod_emitter", 1, {delay = 0.1, effect = "cball_bounce", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(90, 0, 0), "gmod_emitter", 1, {delay = 0.1, effect = "cball_bounce", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
        end,
        ["smoke"] = function(Ent) 
            if Ent["effects"] == nil then Ent["effects"] = {} end
            local effect_scale = (Ent:obbSize().x + Ent:obbSize().y + Ent:obbSize().z) / 5
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(-90, 0, 0), "gmod_emitter", 1, {delay = 0.1, effect = "smoke", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(90, 0, 0), "gmod_emitter", 1, {delay = 0.1, effect = "smoke", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
        end,
        ["water splash"] = function(Ent) 
            if Ent["effects"] == nil then Ent["effects"] = {} end
            local effect_scale = (Ent:obbSize().x + Ent:obbSize().y + Ent:obbSize().z) / 5
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(-90, 0, 0), "gmod_emitter", 1, {delay = 0.1, effect = "watersplash", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(90, 0, 0), "gmod_emitter", 1, {delay = 0.1, effect = "watersplash", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
        end,
        ["fire"] = function(Ent) 
            if Ent["effects"] == nil then Ent["effects"] = {} end
            local effect_scale = (Ent:obbSize().x + Ent:obbSize().y + Ent:obbSize().z) / 10 effect_scale = math.min(effect_scale, 25)
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(-90, 0, 0), "gmod_emitter", 1, {delay = 0, effect = "muzzleeffect", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
            local gmod_emitter = prop.createSent(Ent:localToWorld(Vector(0, 0, Ent:obbSize().z / 2)), Angle(90, 0, 0), "gmod_emitter", 1, {delay = 0, effect = "muzzleeffect", key = 1, Model = "models/props_lab/tpplug.mdl", scale = effect_scale, starton = true, toggle = true}) gmod_emitter:setColor(Color(255, 255, 255, 0)) gmod_emitter:setCollisionGroup(10) gmod_emitter:setParent(Ent) table.add(Ent["effects"], {gmod_emitter})
        end,
        ["remove all effects"] = function(Ent) 
            if Ent["effects"] != nil and #Ent["effects"] > 0 then
                for i = 1, #Ent["effects"] do
                    Ent["effects"][i]:remove()
                end 
                Ent["effects"] = nil
            end
        end,
            
    }
        
    net.receive("sendFunc", function(str)
        local data = net.readTable()
        local func = data.func
        local Ent = entity(data.id)
        
        roped = false
        if Function[func] != nil then
            Function[func](Ent, func)
        else
            local subfunc = string.explode(":", func, nil)
            Function[subfunc[1]](Ent, subfunc[2])
        end        
        
        if roped == false then
            LastEnt = Ent
        else
            LastEnt = nil
        end
    end)
    
    net.receive("throw", function(str)
        if Grabed != nil and GraberEntity != nil and Grabed:isValid() and GraberEntity:isValid() then
            local Throwed = Grabed
            Graber(nil)
            Throwed:applyForceCenter((Throwed:getVelocity() + owner():getEyeTrace().Normal * 1000) * Throwed:getMass())
        end
    end)
    
    net.receive("RemoteUse", function(str)
        local data = net.readTable()
        owner():setPos(data.ent:localToWorld(data.ent:isVehicle() and Vector(30, 30, 0) or Vector()))
        data.ent:use() 
    end)
    
elseif CLIENT then
    
    if player() == owner() then
        Ver = "v0.78"
        print("[EntAdmin][c 255, 155, 0]: loaded " .. Ver .. ". Last update: " .. " now u can Bind functions => Hold [sprint] key, move mouse on buntton and then press any [bind key].")  
        print("[EntAdmin][c 255, 155, 0]: to remove the binding, move the mouse over the button and click [reload]. + large optimization")  
        print("[EntAdmin][c 255, 155, 0]: + simple USE function. Visual updates.")  
        enableHud(nil, true)
        
        Data = {
            john = {
                "не надо трогать Жона",
                "его пропы тоже =)"
            },
            owner = {
                "player functions =>",
                "emit sound =>",
                "kill",
                "drop weapon",
                "drop all weapons",
                "strip weapons",
                "modelSize: 0.5",
                "modelSize: 1.0",
                "modelSize: 2.0",
                "ignite",
                "extinguish",
                "toss me",
                "full heal",
                "teleport to ACID",
                "teleport to Vector(0)",
            },
            player = {
                "player functions =>",
                "emit sound =>",
                "kill",
                "drop weapon",
                "drop all weapons",
                "strip weapons",
                "modelSize: 0.5",
                "modelSize: 1.0",
                "modelSize: 2.0",
                "ignite",
                "extinguish",
                "toss player",
                "full heal",
                "teleport to ACID",
                "teleport to Vector(0)",
    
            },
            other = {
                "constraints =>",
                "mass prop functions =>",
                "emit sound =>",
                "add effect =>",
                "grab / stop grab",
                "remove",
                "break",
                "no Collide",
                "return Collide",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "gravity off",
                "gravity on",
                "remove Trails",
                "set NoDrag",
                "froze",
                "unfroze",
                "toss prop",
                "make spherical",
                "set unbreakable",   
                "set breakable",     
                "teleport to ACID",
                "teleport to Vector(0)", 
                "KeepUpRight",
                "convert to custom prop",
                "add/remove dissolving",
            },
            jail = {
                "emit sound =>",
                "remove jail",
                "no Collide",
                "return Collide",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "set NoDrag",
            },
            class_C_BaseEntity = {
                "remote use =>",
                "use",
            },
            prop_vehicle_prisoner_pod = {
                "constraints =>",
                "vehicle functions =>",
                "mass vehicle functions =>",
                "emit sound =>",
                "remote use =>",
                "add effect =>",
                "grab / stop grab",
                "eject Driver",
                "kill Driver",
                "strip Driver",
                "lock",
                "unlock",
                "remove",
                "no Collide",
                "return Collide",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "gravity off",
                "gravity on",
                "remove Trails",
                "set NoDrag",
                "froze",
                "unfroze",
                "toss prop",
                "teleport to ACID",
                "teleport to Vector(0)", 
                "add/remove dissolving",
                "use",
            },
            prop_vehicle_airboat = {
                "constraints =>",
                "vehicle functions =>",
                "mass vehicle functions =>",
                "emit sound =>",
                "remote use =>",
                "add effect =>",
                "grab / stop grab",
                "eject Driver",
                "kill Driver",
                "strip Driver",
                "lock",
                "unlock",
                "remove",
                "no Collide",
                "return Collide",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "remove Trails",
                "set NoDrag",
                "froze",
                "unfroze",
                "toss vehicle",
                "teleport to ACID",
                "teleport to Vector(0)",    
                "add/remove dissolving",
                "use",
            },
            prop_vehicle_jeep = {
                "constraints =>",
                "vehicle functions =>",
                "mass vehicle functions =>",
                "emit sound =>",
                "remote use =>",
                "add effect =>",
                "grab / stop grab",
                "eject Driver",
                "kill Driver",
                "strip Driver",
                "lock",
                "unlock",
                "remove",
                "no Collide",
                "return Collide",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "gravity off",
                "gravity on",
                "remove Trails",
                "set NoDrag",
                "froze",
                "unfroze",
                "toss vehicle",
                "teleport to ACID",
                "teleport to Vector(0)",  
                "add/remove dissolving",
                "use",
            },
            npc = {
                "emit sound =>",
                "like me",
                "fear me",
                "hate me",
                "neutral me",
                "broke weapon",
                "remove",
                "kill",
            },
            npc_rollermine = {
                "constraints =>",
                "emit sound =>",
                "add effect =>",
                "like me",
                "fear me",
                "hate me",
                "neutral me",
                "broke weapon",
                "remove",
                "kill",
                "add/remove dissolving",
            },
            prop_dynamic = {
                "emit sound =>",
                "remove",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "set NoDrag",
                "teleport to ACID",
                "teleport to Vector(0)", 
            },
            prop_physics_multiplayer = {
                "emit sound =>",
                "grab / stop grab",
                "remove",
                "no Collide",
                "return Collide",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "set NoDrag",
                "froze",
                "unfroze",
                "toss prop",
                "teleport to ACID",
                "teleport to Vector(0)", 
                "add/remove dissolving",
            },
            acf_gun = {
                "constraints =>",
                "emit sound =>",
                --"unload gun",
                "remove",
                "no Collide",
                "return Collide",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "gravity off",
                "gravity on",
                "set NoDrag",
                "froze",
                "unfroze",
                "toss prop",
                "add/remove dissolving",
            },
            func_door = {
                
            },
            prop_door_rotating = {
                "emit sound =>",
                --"remove",
                "no Collide",
                "return Collide",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "remove Trails",
                "set NoDrag",
                "teleport to ACID",
                "teleport to Vector(0)", 
            },
            func_breakable = {
                "emit sound =>",
                "remove",
                "no Collide",
                "return Collide",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "remove Trails",
                "set NoDrag",
                "teleport to ACID",
                "teleport to Vector(0)", 
                "add/remove dissolving",
            },
            gmod_rttv = {
                "constraints =>",
                "emit sound =>",
                "grab / stop grab",
                "remove",
                "break",
                "no Collide",
                "return Collide",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "gravity off",
                "gravity on",
                "remove Trails",
                "set NoDrag",
                "froze",
                "unfroze",
                "toss prop",
                "teleport to ACID",
                "teleport to Vector(0)", 
                "KeepUpRight",
                "add/remove dissolving",
            },
            starfall_prop = {
                "constraints =>",
                "custom prop physics =>",
                "emit sound =>",
                "add effect =>",
                "grab / stop grab",
                "remove",
                "no Collide",
                "return Collide",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "gravity off",
                "gravity on",
                "remove Trails",
                "set NoDrag",
                "froze",
                "unfroze",
                "toss prop", 
                "add/remove dissolving",
            },
            gmod_wire_textscreen = {
                "constraints =>",
                "emit sound =>",
                "add effect =>",
                "grab / stop grab",
                "remove",
                "no Collide",
                "return Collide",
                "make transparent",
                "remove transparency",
                "ignite",
                "extinguish",
                "gravity off",
                "gravity on",
                "remove Trails",
                "set NoDrag",
                "froze",
                "unfroze",
                "toss prop", 
                "teleport to ACID",
                "teleport to Vector(0)", 
                "KeepUpRight",
                "add/remove dissolving",
            }
            
        }
        
        DataConstraints = {
            "rope",    
            "rigid rope",
            "elastic",
            "axis",
            "ballsocket",
            "weld",
            "nocollide",
            "break constraints",
            "", 
            "rope to me",
            "rigid rope to me",
            "elastic to me",
            "axis to me",
            "ballsocket to me",
            "weld to me",
        }
        DataPlayerFunctions = {
            "function [spawnpoint]",
            "function [healing]",
            "function [ban weapons]",
            "function [block moving]",
            "function [block camera]",
            "function [block PROPspawn]",
            "function [block NPCspawn]",
            "function [block Alt+E]",
            "",
            "remove function [spawnpoint]",
            "remove function [healing]",
            "remove function [ban weapons]",
            "remove function [block moving]",
            "remove function [block camera]",
            "remove function [block PROPspawn]",
            "remove function [block NPCspawn]",
            "remove function [block Alt+E]",
        }
        DataVehicleFunctions = {
            "function [kill drivers]",
            "function [eject drivers]",
            "function [strip drivers]",
            "",
            "remove function [kill drivers]",
            "remove function [eject drivers]",
            "remove function [strip drivers]",
        }
        DataMassVehicleFunctions = {
            "function [vehicle can't froze]",
            "remove function [vehicle can't froze]",
        }
        DataCustomPropFunctions = {
            "make balloon",
            "set supergravity",
            "spining physics",
            "wheel physics",
            "thruster physics",
            "set default physics",
        }
        DataSoundFunctions = {
            "loop:ambient/water/water_flow_loop1.wav",
            "loop:ambient/alarms/alarm_citizen_loop1.wav",
            "loop:ambient/alarms/alarm1.wav",
            "loop:ambient/alarms/siren.wav",
            "loop:ambient/energy/force_field_loop1.wav",
            "loop:ambient/energy/electric_loop.wav",
        }
        DataMassPropFunctions = {
            "function [props can't froze]",
            "remove function [props can't froze]",  
        }
        DataRemoteUseFunctions = {
            "remote:KP_PGUP",
            "remote:KP_UPARROW",
            "remote:KP_HOME",
            "remote:KP_RIGHTARROW",
            "remote:KP_5",
            "remote:KP_LEFTARROW",
            "remote:KP_PGDN",
            "remote:KP_DOWNARROW",
            "remote:KP_END",   
            "",
            "clear all buttons", 
        }
        DataEffectFunctions = {
            "large light",
            "explosion",   
            "blood", 
            "strider blood",
            "cball explosion",
            "smoke",
            "water splash",
            "fire",
            "",
            "remove all effects",
        }
        
        DataSkins = {}  for i = 0, 30 do DataSkins[i] = "skin:" .. i end
        
        Button = {}
        Ent = nil
        Ply = owner()
        RemoteUse = {}
        
        BaseColor1 = Color(50, 50, 100, 255)
        BaseColor2 = Color(0, 0, 0, 255)
        BaseColor3 = Color(100, 200, 100, 255)
        BaseColor4 = Color(50, 100, 100, 255)
        
        ConstraintsColor1 = Color(50, 100, 50, 255)
        ConstraintsColor2 = Color(0, 0, 0, 255)
        ConstraintsColor3 = Color(200, 200, 100, 255)
        
        Font1 = render.createFont("Consolas", 15, 50, true)
        Font2 = render.createFont("Consolas", 18, 50, true)
        Font3 = render.createFont("Consolas", 14, 50, true)
        ButtonSize = Vector(250, 30)
        ButtonCorrector = 0.5
        
        Bind = {}
        BindFunc = {}
        
        LogicData = {
            ["isConstraints"] = {value = false, buttonID = 100, data = DataConstraints, tree = "constraints =>"},
            ["isSkins"] = {value = false, buttonID = 200, data = DataSkins, tree = "set skin =>"},
            ["isPlayerFunctions"] = {value = false, buttonID = 300, data = DataPlayerFunctions, tree = "player functions =>"},
            ["isVehicleFunctions"] = {value = false, buttonID = 400, data = DataVehicleFunctions, tree = "vehicle functions =>"},
            ["isCustomPropFunctions"] = {value = false, buttonID = 500, data = DataCustomPropFunctions, tree = "custom prop physics =>"},
            ["isSoundFunctions"] = {value = false, buttonID = 600, data = DataSoundFunctions, tree = "emit sound =>"},
            ["isMassPropFunctions"] = {value = false, buttonID = 700, data = DataMassPropFunctions, tree = "mass prop functions =>"},
            ["isMassVehicleFunctions"] = {value = false, buttonID = 800, data = DataMassVehicleFunctions, tree = "mass vehicle functions =>"},
            ["isRemoteUseFunctions"] = {value = false, buttonID = 900, data = DataRemoteUseFunctions, tree = "remote use =>"},
            ["isEffectFunctions"] = {value = false, buttonID = 1000, data = DataEffectFunctions, tree = "add effect =>"},
        }

        local function getStorage()
            local data = {}
            if (Ent:getOwner()!= nil and Ent:getOwner():getSteamID()) == John and owner():getSteamID() != John then
                data = table.copy(Data["john"])
            elseif Ent == owner() then
                data = table.copy(Data["owner"])
            elseif Ent:getModel() == "models/props_building_details/storefront_template001a_bars.mdl" and Ent:getOwner() == nil then
                data = table.copy(Data["jail"])
            elseif Data[string.replace(Ent:getClass(), " ", "_")] != nil then
                data = table.copy(Data[string.replace(Ent:getClass(), " ", "_")])
            elseif Ent:isNPC() then
                data = table.copy(Data["npc"])
            else
                data = table.copy(Data["other"])
            end
            return data
        end
        
        local function closeTrees()
            for u = 1, table.count(LogicData) do
                local key = table.getKeys(LogicData)[u]
                LogicData[key].value = false
            end
        end
        closeTrees()
        
        function checkTrees()
            local num = 0
            for u = 1, table.count(LogicData) do
                local key = table.getKeys(LogicData)[u]
                if LogicData[key].value == true then
                    for i = 1, table.count(LogicData[key].data) do
                        num = num + (Button[LogicData[key].buttonID + i] and 1 or 0)
                    end
                end
            end
            return num 
        end
        
        function getDatBind(dat)
            local value = ""
            if Ent[dat] != nil then
                value = (Ent[dat] == nil) and "" or " [" .. input.getKeyName(tonumber(string.explode(":", Ent[dat])[2])) .. "]"
            end
            return value
        end
        
        timer.create("check trees", 1, 0, function()
            if checkTrees() == 0 then
                closeTrees()
            end    
        end)
        
        hook.add("drawhud", "", function()
            
            if ResX == nil then
               ResX, ResY = render.getResolution() 
            end
            
            if Ent != nil then
                if Ent:isValid() then
                    local mouseX, mouseY = input.getCursorPos()
                    
                    render.setFont(Font1)
                    
                    local data = table.copy(getStorage())
                    local isJohn = data == Data["john"]
                    if not isJohn then
                        if (Ent:getSkinCount() or 0) > 1 then
                           table.insert(data, 1, "set skin =>") 
                        end
                    end
                    
                    local x, y = ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    render.setColor(BaseColor1 * 2)
                    render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                    render.setColor(BaseColor2 * 2)
                    render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                    render.setColor(Color(255, 255, 255))
                    render.drawText(x + ButtonSize.x / 2, y + 5, tostring(Ent), 1)
                    render.setFont(Font3)
                    
                    if checkTrees() == 0 then
                        timer.unpause("check trees")
                    else
                        timer.pause("check trees")
                    end
                    
                    if table.count(data) > 0 then
                        for i = 1, table.count(data) do
                            local dat = data[table.getKeys(data)[i]]
                            y = y + ButtonSize.y
                            if not isJohn and dat != "" then
                                Button[i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                            end
                            if string.match(dat, "=>", nil) then
                                render.setColor(Button[i] and ConstraintsColor3 or ConstraintsColor1)
                                
                                for u = 1, table.count(LogicData) do
                                    local key = table.getKeys(LogicData)[u]
                                    if dat == LogicData[key].tree then
                                        if LogicData[key].value == false then
                                            LogicData[key].value = Button[i]
                                            if LogicData[key].value == true then
                                                closeTrees()
                                                LogicData[key].value = true
                                            end
                                        end
                                    end
                                end
                            else
                                render.setColor(Button[i] and BaseColor3 or BaseColor1)
                            end
                            render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                            local datbind = getDatBind(dat)
                            render.setColor(string.match(dat, "=>", nil) and ConstraintsColor2 or BaseColor2)
                            render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                            if datbind != "" then
                                render.drawRectOutline(x + 2, y + 2, ButtonSize.x - 4, ButtonSize.y - 4, 2)
                            end
                            render.setColor(Button[i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                            render.drawText(x + ButtonSize.x / 2, y + 5, dat .. datbind, 1)
                        end
                    else
                        y = y + ButtonSize.y
                        render.setColor(BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, "нет доступных функций", 1)
                    end
                    
                    for u = 1, table.count(LogicData) do
                        local key = table.getKeys(LogicData)[u]
                        if LogicData[key].value == true then
                            local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                            local data = LogicData[key].data
                            local butID = LogicData[key].buttonID
                            
                            for i = 1, (key != "isSkins" and table.count(data) or math.min(table.count(data), Ent:getSkinCount())) do
                                local dat = data[table.getKeys(data)[i]]
                                y = y + ButtonSize.y
                                if dat != "" then
                                    Button[butID + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                                end
                                
                                if key == "isSkins" then
                                    render.setColor(Button[butID + i] and BaseColor3 or (tonumber(string.replace(dat, "skin:", "")) != Ent:getSkin() and BaseColor1 or BaseColor4))
                                elseif key == "isCustomPropFunctions" then
                                    render.setColor(Button[butID + i] and BaseColor3 or (Ent["forces"] != dat and BaseColor1 or BaseColor4))
                                elseif key == "isRemoteUseFunctions" then
                                    text = string.explode(":", dat, false)[2] or dat
                                    render.setColor(Button[butID + i] and BaseColor3 or (RemoteUse[text] == nil and BaseColor1 or BaseColor4))
                                else
                                    render.setColor(Button[butID + i] and BaseColor3 or BaseColor1)
                                end
                                
                                render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                                render.setColor(BaseColor2)
                                local datbind = getDatBind(dat)
                                render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                                if datbind != "" then
                                    render.drawRectOutline(x + 2, y + 2, ButtonSize.x - 4, ButtonSize.y - 4, 2)
                                end
                                render.setColor(Button[butID + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                                
                                if key == "isSkins" then
                                    render.drawText(x + ButtonSize.x / 2, y + 5, (tonumber(string.replace(dat, "skin:", "")) == Ent:getSkin() and " => " .. dat .. " <=" or dat) .. datbind, 1)
                                elseif key == "isCustomPropFunctions" then
                                    render.drawText(x + ButtonSize.x / 2, y + 5, (Ent["forces"] != dat and dat or "=> " .. dat .. " <=") .. datbind, 1)
                                elseif key == "isSoundFunctions" then
                                    render.drawText(x + ButtonSize.x / 2, y + 5, (string.explode(":", dat, false)[2] or dat) .. datbind, 1)
                                elseif key == "isRemoteUseFunctions" then
                                    render.drawText(x + ButtonSize.x / 2, y + 5, (RemoteUse[text] == nil and text or "=[ " .. text .. " ]=") .. datbind, 1)
                                else
                                    render.drawText(x + ButtonSize.x / 2, y + 5, dat .. datbind, 1)
                                end
                            end
                        end                    
                    end
                        
                else
                    Ent = nil
                    input.enableCursor(false)
                    closeTrees()
                    Ply:emitSound("buttons/button8.wav", 75, 125, 0.75, CHAN_AUTO)
                end
            end
            
        end)
        
        function findTarget()
            local Angles = Ply:getEyeAngles()
            if Angles[1] == 89 and math.abs(Angles[3]) < 10 then
                Ent = owner()
                input.enableCursor(true)
                Ply:emitSound("buttons/button7.wav", 75, 125, 0.75, CHAN_AUTO)
            else
                if Ply:getEyeTrace().Entity:getClass() != "worldspawn" then
                    Ent = Ply:getEyeTrace().Entity
                    --print(Ply:getEyeTrace().Entity:getClass())
                    input.enableCursor(true)
                    Ply:emitSound("buttons/button7.wav", 75, 125, 0.75, CHAN_AUTO)
                end
            end
        end
        
        function sendData(data, i)
            net.start("sendFunc")
            net.writeTable({id = Ent:entIndex(), func = data[i]})
            net.send(Ply)
            Ent["forces"] = data[i]
            Ent = nil
            input.enableCursor(false)
            Ply:emitSound("buttons/button3.wav", 75, 125, 0.75, CHAN_AUTO)
            closeTrees()
        end
        
        function setBind(data, i, key, ent)
            if Bind["key:" .. key] == nil then
                Bind["key:" .. key] = {func = data[i], ent = ent}
                ent[data[i]] = "key:" .. key
            else
                Bind["key:" .. key].ent[data[i]] = nil
                Bind["key:" .. key] = {func = data[i], ent = ent}
                ent[data[i]] = "key:" .. key
            end
            Ply:emitSound("buttons/combine_button1.wav", 100, 150, 0.75, CHAN_AUTO)
        end
        
        function unbind(data, i, key, ent)
            if BindFunc[data[i]] != nil then
                if Bind[BindFunc[data[i]]].ent == ent then
                    BindFunc[data[i]] = nil
                    Bind["key:" .. key] = nil
                    Ply:emitSound("buttons/combine_button2.wav", 100, 150, 0.75, CHAN_AUTO)
                end
            end
        end
            
        function checkButtons(data, type, key, ent)
            for i = 1, table.count(data) do
                if Button[i] and not string.match(data[i], "=>", nil) then
                    if type == "func" then 
                        sendData(data, i) 
                    elseif type == "bind" then
                        setBind(data, i, key, ent)
                    elseif type == "unbind" then
                        unbind(data, i, key, ent)
                    end
                end
            end
            for u = 1, table.count(LogicData) do
                local keytable = table.getKeys(LogicData)[u]
                if LogicData[keytable].value == true then
                    local data = LogicData[keytable].data
                    for i = 1, table.count(data) do
                        if Button[LogicData[keytable].buttonID + i] then
                            if type == "func" then 
                                sendData(data, i) 
                            elseif type == "bind" then
                                setBind(data, i, key, ent)
                            elseif type == "unbind" then
                                unbind(data, i, key, ent)
                            end
                        end
                    end
                end
            end
        end
        
        function checkInputTrees()
            local value = false 
            for u = 1, table.count(LogicData) do
                local key = table.getKeys(LogicData)[u]
                if LogicData[key].value == true then 
                    value = true 
                end
            end
            return value
        end
        
        net.receive("RemoteUseData", function(str)
            RemoteUse = net.readTable()
        end)
        
        hook.add("inputPressed", "", function(key)
            if Ent == nil then
                for i = 1, table.count(Bind) do
                    local bind = table.getKeys(Bind)[i]
                    if key == tonumber(string.explode(":", bind)[2]) then
                        if Bind[bind].ent:isValid() then
                            net.start("sendFunc")
                            net.writeTable({id = Bind[bind].ent:entIndex(), func = Bind[bind].func})
                            net.send(Ply)    
                        end
                    end
                end                
            end

            if RemoteUse[input.getKeyName(key)] != nil then
                net.start("RemoteUse")
                net.writeTable({ent = RemoteUse[input.getKeyName(key)]})
                net.send(owner())
                Ply:emitSound("buttons/combine_button1.wav", 100, 150, 1, CHAN_AUTO)
            end
            
            if key == 108 and Ent == nil then
                if Ply:isValid() then
                    if Ply:getActiveWeapon():isValid() then
                        if Ply:getActiveWeapon():getClass() == "weapon_empty_hands" then
                            findTarget()
                        end
                    else
                        findTarget()
                    end
                end
            elseif key == 108 and Ent != nil then
                Ent = nil
                input.enableCursor(false)
                Ply:emitSound("buttons/button7.wav", 75, 50, 0.75, CHAN_AUTO)
            elseif Ent == nil then
                if key == 107 then
                    net.start("throw")
                    net.writeTable({func = "da"})
                    net.send(owner())
                end
            elseif Ent != nil then
                if key == 107 then
                    local data = getStorage()
                    if (Ent:getSkinCount() or 0) > 1 then
                       table.insert(data, 1, "set skin =>") 
                    end
                    local mouseX, mouseY = input.getCursorPos()
                    
                    local isTrees = checkInputTrees()

                    local inmenu = Vector(mouseX, mouseY):withinAABox(Vector(ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)), Vector(ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)) + Vector(ButtonSize.x * (isTrees and 2 or 1), 1000))
                    if inmenu then
                        checkButtons(data, "func")
                    else
                        Ent = nil
                        input.enableCursor(false)
                        closeTrees()
                        Ply:emitSound("buttons/button7.wav", 75, 50, 0.75, CHAN_AUTO)
                    end
                elseif key == 28 and not owner():keyDown(131072) then
                    local data = getStorage()
                    if (Ent:getSkinCount() or 0) > 1 then
                       table.insert(data, 1, "set skin =>") 
                    end
                    local mouseX, mouseY = input.getCursorPos()
                    
                    local isTrees = checkInputTrees()
                    
                    local inmenu = Vector(mouseX, mouseY):withinAABox(Vector(ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)), Vector(ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)) + Vector(ButtonSize.x * (isTrees and 2 or 1), 1000))
                    if inmenu then
                        checkButtons(data, "unbind", key, Ent)
                    else
                        Ent = nil
                        input.enableCursor(false)
                        closeTrees()
                        Ply:emitSound("buttons/button7.wav", 75, 50, 0.75, CHAN_AUTO)
                    end
                else
                    if owner():keyDown(131072) then
                        local data = getStorage()
                        if (Ent:getSkinCount() or 0) > 1 then
                           table.insert(data, 1, "set skin =>") 
                        end
                        local mouseX, mouseY = input.getCursorPos()
                        
                        local isTrees = checkInputTrees()
                        
                        local inmenu = Vector(mouseX, mouseY):withinAABox(Vector(ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)), Vector(ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)) + Vector(ButtonSize.x * (isTrees and 2 or 1), 1000))
                        if inmenu then
                            checkButtons(data, "bind", key, Ent)
                        else
                            Ent = nil
                            input.enableCursor(false)
                            closeTrees()
                            Ply:emitSound("buttons/button7.wav", 75, 50, 0.75, CHAN_AUTO)
                        end
                    end
                    
                end
            end
        end)
        
        DataMesh = nil
        timer.create("custom", 1, 0, function()
            if DataMesh != nil then
                local ent = entity(DataMesh.entID)
                local mat = DataMesh.mat[math.random(1, #DataMesh.mat)]
                
                if ent:isValid() then
                    if ent:getPhysicsObject():isValid() then
                        ent:setMeshMaterial(material.load(mat))
                        local tbl = ent:getPhysicsObject():getMesh()
                        mesh.generateUV(tbl, 0.1)
                        mesh.generateNormals(tbl, true)
                        mesh.generateTangents(tbl)
                        ent:setMesh(mesh.createFromTable(tbl))
                        DataMesh = nil
                    end
                end
            end
        end)
        
        net.receive("CustomProp+Material", function(str)
            DataMesh = net.readTable()    
        end)
        
    else
        
        DataMesh = nil
        timer.create("custom", 1, 0, function()
            if DataMesh != nil then
                local ent = entity(DataMesh.entID)
                local mat = DataMesh.mat[math.random(1, #DataMesh.mat)]
                
                if ent:isValid() then
                    if ent:getPhysicsObject():isValid() then
                        ent:setMeshMaterial(material.load(mat))
                        local tbl = ent:getPhysicsObject():getMesh()
                        mesh.generateUV(tbl, 0.1)
                        mesh.generateNormals(tbl, true)
                        mesh.generateTangents(tbl)
                        ent:setMesh(mesh.createFromTable(tbl))
                        DataMesh = nil
                    end
                end
            end
        end)
        
        net.receive("CustomProp+Material", function(str)
            DataMesh = net.readTable()    
        end)
        
    end
    
end
