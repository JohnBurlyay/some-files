--@name EntityAdministrator-v0.61
--@author JohnBurlyay
--@shared
--@model models/cheeze/buttons2/deactivate.mdl

if SERVER then

    chip():setCollisionGroup(10)
    LastEnt = nil
    Holo = {}
    O = owner()  
    BaseProp = nil

    function holo(id, model, pos, ang, scale, mat, color, parent)
        Holo[id] = holograms.create(pos, ang, model, scale)
        Holo[id]:setMaterial(mat)
        Holo[id]:setColor(color)
        Holo[id]:setParent(parent)
        return Holo[id]
    end
    
    holo(1, "models/hunter/blocks/cube025x025x025.mdl", O:localToWorld(Vector(0, 0, 0)), O:worldToLocalAngles(Angle(0, 0, 0)), Vector(1, 1, 1), "", Color(255, 255, 255, 0), O:getActiveWeapon())
    BaseProp = prop.create(Holo[1]:getPos(), Angle(), "models/led.mdl", 1)
    BaseProp:setNocollideAll(true)
    BaseProp:setColor(Color(255, 255, 255, 0))
    BaseProp:setParent(Holo[1])      
    
    timer.create("respawn", 1, 0, function()
        if O:isAlive() then
            if not Holo[1]:isValid() and hologram.canSpawn() and O:getActiveWeapon():isValid() then
                holo(1, "models/hunter/blocks/cube025x025x025.mdl", O:localToWorld(Vector(0, 0, 0)), O:worldToLocalAngles(Angle(0, 0, 0)), Vector(1, 1, 1), "", Color(255, 255, 255, 0), O:getActiveWeapon())
                --print("holo respawn!")
            end
            if not BaseProp:isValid() and prop.canSpawn() and Holo[1]:isValid() then
                BaseProp = prop.create(Holo[1]:getPos(), Angle(), "models/led.mdl", 1)
                BaseProp:setNocollideAll(true)
                BaseProp:setColor(Color(255, 255, 255, 0))
                BaseProp:setParent(Holo[1])
                --print("baseprop respawn!")
            end
        end
    end)
    
    hook.add("think", "", function()
        if BaseProp:isValid() and Holo[1]:isValid() then
            local Props = BaseProp:getAllConstrained(nil)
            if #Props > 0 then
                for i = 1, #Props do
                    local P = Props[i]
                    if P:isValidPhys() and P != O and P != BaseProp then
                        P:applyForceCenter(Vector(0, 0, 1))
                    end
                end 
            end
            --BaseProp:setPos(Holo[1]:getPos())
        end
    end)
    
    VehicleFunctions = {
        kill = {},
        eject = {},
        strip = {},    
    }
    PlayerFunctions = {
        respawn = {},
        heal = {},    
        strip = {}
    }
    
    hook.add("PlayerEnteredVehicle", "", function(ply, vehicle, num)
        if table.hasValue(VehicleFunctions.kill, vehicle) then
            vehicle:killDriver()
        end
        if table.hasValue(VehicleFunctions.eject, vehicle) then
            vehicle:ejectDriver()
        end
        if table.hasValue(VehicleFunctions.strip, vehicle) then
            vehicle:stripDriver()
        end
    end)
    
    hook.add("PlayerSpawn", "", function(ply)
        if table.count(PlayerFunctions.respawn[ply:getSteamID()] or {}) > 1 then
            if PlayerFunctions.respawn[ply:getSteamID()].pos != Vector() then
                ply:setPos(PlayerFunctions.respawn[ply:getSteamID()].pos)
            end
        end
    end)
    
    hook.add("PlayerHurt", "", function(ply, attacker, newHealth, damageTaken)
        if table.count(PlayerFunctions.heal[ply:getSteamID()] or {}) > 1 then
            if PlayerFunctions.heal[ply:getSteamID()].heal != 0 then
                ply:setHealth(newHealth + math.round(damageTaken))
            end
        end
    end)
    
    hook.add("PlayerSwitchWeapon", "", function(ply, oldwep, newweapon)
        if table.count(PlayerFunctions.strip[ply:getSteamID()] or {}) > 1 then
            if PlayerFunctions.strip[ply:getSteamID()].strip != 0 then
                ply:stripWeapons()
            end
        end
    end)
    
    Function = {
    --props
        ["remove"] = function(Ent) Ent:remove() end,   
        ["no Collide"] = function(Ent) Ent:setNocollideAll(true) end,
        ["return Collide"] = function(Ent) Ent:setNocollideAll(false) end,
        ["make transparent"] = function(Ent) Ent:setColor(Color(Ent:getColor()[1], Ent:getColor()[2], Ent:getColor()[3], 0)) end,
        ["remove transparency"] = function(Ent) Ent:setColor(Color(Ent:getColor()[1], Ent:getColor()[2], Ent:getColor()[3], 255)) end,
        ["gravity off"] = function(Ent) Ent:enableGravity(false) end,
        ["gravity on"] = function(Ent) Ent:enableGravity(true) end,
        ["remove Trails"] = function(Ent) Ent:removeTrails() end,
        ["set NoDrag"] = function(Ent) Ent:setCollisionGroup(10) end,
        ["froze"] = function(Ent) Ent:setFrozen(true) end,
        ["unfroze"] = function(Ent) Ent:setFrozen(false) end,
        ["toss prop"] = function(Ent) Ent:applyForceCenter(((Ent:getPos() - owner():getPos()) / Ent:getPos():getDistance(owner():getPos()) * 250 + Vector(0, 0, 250)) * Ent:getMass()) end,
        ["break"] = function(Ent) Ent:breakEnt() end,
        ["break constraints"] = function(Ent) constraint.breakAll(Ent) end,
        ["make spherical"] = function(Ent) Ent:enableSphere(true, nil) end,
        ["set breakable"] = function(Ent) Ent:setUnbreakable(false) end,
        ["set unbreakable"] = function(Ent) Ent:setUnbreakable(true) end,
        ["rope"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.rope(Ent:entIndex(), LastEnt, Ent, nil, nil, Vector(), Vector(), 0, 0, 0, 2, "cable/rope", false, nil) roped = true end end end,
        ["rigid rope"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.rope(Ent:entIndex(), LastEnt, Ent, nil, nil, Vector(), Vector(), 0, 0, 0, 2, "cable/cable2", true, nil) roped = true end end end,
        ["axis"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.axis(LastEnt, Ent, nil, nil, Vector(), Vector(), 0, 0, 0, true, nil) roped = true end end end,
        ["elastic"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.elastic(Ent:entIndex(), LastEnt, Ent, nil, nil, Vector(), Vector(), nil, nil, nil, 2, false) roped = true end end end,
        ["ballsocket"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.ballsocket(LastEnt, Ent, nil, nil, Vector(), 0, 0, true) roped = true end end end,
        ["weld"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.weld(LastEnt, Ent, nil, nil, 0, true) roped = true end end end,
        ["nocollide"] = function(Ent) if LastEnt != nil then if LastEnt:isValid() and LastEnt != Ent then constraint.nocollide(LastEnt, Ent, nil, nil) roped = true end end end,
        ["KeepUpRight"] = function(Ent) constraint.keepupright(Ent, Ent:getAngles(), 0, 50000) end,
        ["rope to me"] = function(Ent) constraint.rope(Ent:entIndex(), Ent, BaseProp, nil, nil, Vector(), Vector(), 0, 0, 0, 2, "cable/rope", false, nil) end,
        ["rigid rope to me"] = function(Ent) constraint.rope(Ent:entIndex(), Ent, BaseProp, nil, nil, Vector(), Vector(), 0, 0, 0, 2, "cable/rope", true, nil) end,
        ["elastic to me"] = function(Ent) constraint.elastic(Ent:entIndex(), Ent, BaseProp, nil, nil, Vector(), Vector(), nil, nil, nil, 2, false) end,
        ["axis to me"] = function(Ent) constraint.axis(Ent, BaseProp, nil, nil, Vector(), Vector(), 0, 0, 0, true, nil) end,
        ["ballsocket to me"] = function(Ent) constraint.ballsocket(Ent, BaseProp, nil, nil, Vector(), 0, 0, true) end,
        ["weld to me"] = function(Ent) constraint.weld(Ent, BaseProp, nil, nil, 0, true) end,
        ["ignite"] = function(Ent) Ent:ignite(999, nil) end,
        ["extinguish"] = function(Ent) Ent:extinguish() end,
            
    --jail  
        ["remove jail"] = function(Ent) Ent:setPos(Vector(-7777)) Ent:setParent(entity(127)) end,
            
    --player
        ["drop weapon"] = function(Ent) if Ent:getActiveWeapon():isValid() then Ent:dropWeapon(Ent:getActiveWeapon(), nil, nil) end end,
        ["modelSize: 0.5"] = function(Ent) Ent:setModelScale(0.5) end,
        ["modelSize: 1.0"] = function(Ent) Ent:setModelScale(1) end,
        ["modelSize: 2.0"] = function(Ent) Ent:setModelScale(2) end,
        ["toss player"] = function(Ent) Ent:setVelocity(((Ent:getPos() - owner():getPos()) / Ent:getPos():getDistance(owner():getPos()) * 25 + Vector(0, 0, 25)) * math.random(10, 20)) end,
        ["kill"] = function(Ent) Ent:applyDamage(999999, entity(127), entity(127)) end,
        ["strip weapons"] = function(Ent) Ent:stripWeapons() end,
        ["full heal"] = function(Ent) Ent:setHealth(Ent:getMaxHealth()) end,
        ["teleport to ACID"] = function(Ent) Ent:setPos(Vector(9350, 8495, -11500)) end,
        ["teleport to Vector(0)"] = function(Ent) Ent:setPos(Vector(0)) end,
        ["drop all weapons"] = function(Ent) for i = 1, table.count(Ent:getWeapons()) do if Ent:getActiveWeapon():isValid() then Ent:dropWeapon(Ent:getActiveWeapon(), nil, nil) end end end,
        ["function [spawnpoint]"] = function(Ent) if table.count(PlayerFunctions.respawn[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.respawn[Ent:getSteamID()] = {pos = Ent:getPos(), id = Ent:getSteamID()} end end,
        ["remove function [spawnpoint]"] = function(Ent) PlayerFunctions.respawn[Ent:getSteamID()] = nil end,
        ["function [healing]"] = function(Ent) if table.count(PlayerFunctions.heal[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.heal[Ent:getSteamID()] = {heal = 1, id = Ent:getSteamID()} end end,
        ["remove function [healing]"] = function(Ent) PlayerFunctions.heal[Ent:getSteamID()] = nil end,
        ["function [ban weapons]"] = function(Ent) if table.count(PlayerFunctions.strip[Ent:getSteamID()] or {}) <= 1 then PlayerFunctions.strip[Ent:getSteamID()] = {strip = 1, id = Ent:getSteamID()} end Ent:stripWeapons() end,
        ["remove function [ban weapons]"] = function(Ent) PlayerFunctions.strip[Ent:getSteamID()] = nil end,
            
    --vehicle
        ["eject Driver"] = function(Ent) Ent:ejectDriver() end,
        ["kill Driver"] = function(Ent) Ent:killDriver() end,
        ["strip Driver"] = function(Ent) Ent:stripDriver() end,
        ["lock"] = function(Ent) Ent:lock() end,
        ["unlock"] = function(Ent) Ent:unlock() end,
        ["toss vehicle"] = function(Ent) Ent:applyForceCenter(((Ent:getPos() - owner():getPos()) / Ent:getPos():getDistance(owner():getPos()) * 250 + Vector(0, 0, 250)) * Ent:getMass() * 2) end,
        ["function [kill drivers]"] = function(Ent) table.add(VehicleFunctions.kill, {Ent}) end,
        ["remove function [kill drivers]"] = function(Ent) table.removeByValue(VehicleFunctions.kill, Ent) end,
        ["function [eject drivers]"] = function(Ent) table.add(VehicleFunctions.eject, {Ent}) end,
        ["remove function [eject drivers]"] = function(Ent) table.removeByValue(VehicleFunctions.eject, Ent) end,
        ["function [strip drivers]"] = function(Ent) table.add(VehicleFunctions.strip, {Ent}) end,
        ["remove function [strip drivers]"] = function(Ent) table.removeByValue(VehicleFunctions.strip, Ent) end,
            
    --npc
        ["like me"] = function(Ent) Ent:addEntityRelationship(owner(), "like", 99) end,
        ["fear me"] = function(Ent) Ent:addEntityRelationship(owner(), "fear", 99) end,
        ["hate me"] = function(Ent) Ent:addEntityRelationship(owner(), "hate", 99) end,
        ["neutral me"] = function(Ent) Ent:addEntityRelationship(owner(), "neutral", 99) end,
        ["broke weapon"] = function(Ent) Ent:giveWeapon("weapon_empty_hands") end,
        
    }
    for i = 1, 30 do Function["skin " .. i] = function(Ent) Ent:setSkin(i - 1) end end
        
    net.receive("sendFunc", function(str)
        local data = net.readTable()
        local func = data.func
        local Ent = entity(data.id)
        
        roped = false
        Function[func](Ent)
        
        if roped == false then
            LastEnt = Ent
        else
            LastEnt = nil
        end
    end)
    
elseif CLIENT then
    
    if player() != owner() then return end
    Ver = "v0.61"
    print("[EntAdmin][c 255, 155, 0]: loaded " .. Ver .. ". Last update:" .. " fixed some crush, some optimization. Added functions for player/vehicle. Now you can target yourself.")  
    enableHud(nil, true)
    John = "STEAM_0:1:98261831"
    
    Data = {
        john = {
            "не надо трогать Жона",
            "его пропы тоже =)"
        },
        owner = {
            "player functions =>",
            "kill",
            "drop weapon",
            "drop all weapons",
            "strip weapons",
            "modelSize: 0.5",
            "modelSize: 1.0",
            "modelSize: 2.0",
            "ignite",
            "extinguish",
            "full heal",
            "teleport to ACID",
            "teleport to Vector(0)",
        },
        player = {
            "player functions =>",
            "kill",
            "drop weapon",
            "drop all weapons",
            "strip weapons",
            "modelSize: 0.5",
            "modelSize: 1.0",
            "modelSize: 2.0",
            "ignite",
            "extinguish",
            "toss player",
            "full heal",
            "teleport to ACID",
            "teleport to Vector(0)",

        },
        other = {
            "constraints =>",
            "remove",
            "break",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "gravity off",
            "gravity on",
            "remove Trails",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss prop",
            "make spherical",
            "set unbreakable",   
            "set breakable",     
            "teleport to ACID",
            "teleport to Vector(0)", 
            "KeepUpRight",
        },
        jail = {
            "remove jail",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "set NoDrag",
        },
        class_C_BaseEntity = {
            
        },
        prop_vehicle_prisoner_pod = {
            "constraints =>",
            "vehicle functions =>",
            "eject Driver",
            "kill Driver",
            "strip Driver",
            "lock",
            "unlock",
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "gravity off",
            "gravity on",
            "remove Trails",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss prop",
            "teleport to ACID",
            "teleport to Vector(0)", 
        },
        prop_vehicle_airboat = {
            "constraints =>",
            "vehicle functions =>",
            "eject Driver",
            "kill Driver",
            "strip Driver",
            "lock",
            "unlock",
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "remove Trails",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss vehicle",
            "teleport to ACID",
            "teleport to Vector(0)",    
        },
        prop_vehicle_jeep = {
            "constraints =>",
            "vehicle functions =>",
            "eject Driver",
            "kill Driver",
            "strip Driver",
            "lock",
            "unlock",
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "gravity off",
            "gravity on",
            "remove Trails",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss vehicle",
            "teleport to ACID",
            "teleport to Vector(0)",  

        },
        npc = {
            "like me",
            "fear me",
            "hate me",
            "neutral me",
            "broke weapon",
            "remove",
            "kill"
        },
        prop_dynamic = {
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "set NoDrag",
            "froze",
            "unfroze",
            "teleport to ACID",
            "teleport to Vector(0)", 
        },
        prop_physics_multiplayer = {
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss prop",
            "teleport to ACID",
            "teleport to Vector(0)", 
        },
        acf_gun = {
            "constraints =>",
            "unload gun",
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "gravity off",
            "gravity on",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss prop",
        },
        func_door = {
            
        },
        prop_door_rotating = {
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "remove Trails",
            "set NoDrag",
            "teleport to ACID",
            "teleport to Vector(0)", 
        },
        func_breakable = {
            "remove",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "remove Trails",
            "set NoDrag",
            "teleport to ACID",
            "teleport to Vector(0)", 
        },
        gmod_rttv = {
            "constraints =>",
            "remove",
            "break",
            "no Collide",
            "return Collide",
            "make transparent",
            "remove transparency",
            "ignite",
            "extinguish",
            "gravity off",
            "gravity on",
            "remove Trails",
            "set NoDrag",
            "froze",
            "unfroze",
            "toss prop",
            "teleport to ACID",
            "teleport to Vector(0)", 
            "KeepUpRight",
        },
        
    }
    
    DataConstraints = {
        "rope",    
        "rigid rope",
        "elastic",
        "axis",
        "ballsocket",
        "weld",
        "nocollide",
        "break constraints",
        "", 
        "rope to me",
        "rigid rope to me",
        "elastic to me",
        "axis to me",
        "ballsocket to me",
        "weld to me",
    }
    DataPlayerFunctions = {
        "function [spawnpoint]",
        "function [healing]",
        "function [ban weapons]",
        "remove function [spawnpoint]",
        "remove function [healing]",
        "remove function [ban weapons]",
    }
    DataVehicleFunctions = {
        "function [kill drivers]",
        "function [eject drivers]",
        "function [strip drivers]",
        "remove function [kill drivers]",
        "remove function [eject drivers]",
        "remove function [strip drivers]",
    }
    
    DataSkins = {}  for i = 0, 30 do DataSkins[i] = "skin " .. i end
    
    Button = {}
    Ent = nil
    Ply = owner()
    
    BaseColor1 = Color(50, 50, 100, 255)
    BaseColor2 = Color(0, 0, 0, 255)
    BaseColor3 = Color(100, 200, 100, 255)
    
    ConstraintsColor1 = Color(50, 100, 50, 255)
    ConstraintsColor2 = Color(0, 0, 0, 255)
    ConstraintsColor3 = Color(200, 200, 100, 255)
    
    Font1 = render.createFont("Consolas", 15, 50, true)
    Font2 = render.createFont("Consolas", 18, 50, true)
    ButtonSize = Vector(250, 30)
    ButtonCorrector = 0.5
    
    isConstraints = false
    isSkins = false
    isPlayerFunctions = false
    isVehicleFunctions = false
    
    local function getStorage()
        local data = {}
        if (Ent:getOwner()!= nil and Ent:getOwner():getSteamID()) == John and owner():getSteamID() != John then
            data = table.copy(Data["john"])
        elseif Ent == owner() then
            data = table.copy(Data["owner"])
        elseif Ent:getModel() == "models/props_building_details/storefront_template001a_bars.mdl" and Ent:getOwner() == nil then
            data = table.copy(Data["jail"])
        elseif Ent:isNPC() then
            data = table.copy(Data["npc"])
        elseif Data[Ent:getClass():replace(" ", "_")] != nil then
            data = table.copy(Data[Ent:getClass():replace(" ", "_")])
        else
            data = table.copy(Data["other"])
        end
        return data
    end
    
    local function closeTrees()
        isConstraints = false
        isSkins = false
        isPlayerFunctions = false
        isVehicleFunctions = false
    end
    
    function checkTrees()
        local num = 0
        if isConstraints == true then
            for i = 1, table.count(DataConstraints) do
                num = num + (Button[100 + i] and 1 or 0)
            end
        elseif isSkins == true then
            for i = 1, table.count(DataSkins) do
                num = num + (Button[200 + i] and 1 or 0)
            end
        elseif isPlayerFunctions == true then
            for i = 1, table.count(DataPlayerFunctions) do
                num = num + (Button[300 + i] and 1 or 0)
            end
        elseif isVehicleFunctions == true then
            for i = 1, table.count(DataVehicleFunctions) do
                num = num + (Button[400 + i] and 1 or 0)
            end
        end
        return num 
    end
    
    timer.create("check trees", 1, 0, function()
        if checkTrees() == 0 then
            closeTrees()
        end    
    end)
    
    hook.add("drawhud", "", function()
        
        if ResX == nil then
           ResX, ResY = render.getResolution() 
        end
        
        if Ent != nil then
            if Ent:isValid() then
                local mouseX, mouseY = input.getCursorPos()
                
                render.setFont(Font1)
                
                local data = table.copy(getStorage())
                local isJohn = data == Data["john"]
                if not isJohn then
                    if (Ent:getSkinCount() or 0) > 1 then
                       table.insert(data, 1, "set skin =>") 
                    end
                end
                
                local x, y = ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                render.setColor(BaseColor1 * 2)
                render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                render.setColor(BaseColor2 * 2)
                render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                render.setColor(Color(255, 255, 255))
                render.drawText(x + ButtonSize.x / 2, y + 5, tostring(Ent), 1)
                render.setFont(Font2)
                
                if checkTrees() == 0 then
                    timer.unpause("check trees")
                else
                    timer.pause("check trees")
                end
                --print(num)
                
                if table.count(data) > 0 then
                    for i = 1, table.count(data) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if not isJohn and dat != "" then
                            Button[i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        if string.match(dat, "=>", nil) then
                            render.setColor(Button[i] and ConstraintsColor3 or ConstraintsColor1)
                            if dat == "constraints =>" then
                                if isConstraints == false then
                                    isConstraints = Button[i]
                                    if isConstraints == true then
                                        isSkins = false
                                        isPlayerFunctions = false
                                        isVehicleFunctions = false
                                    end
                                end
                            elseif dat == "set skin =>" then
                                if isSkins == false then
                                    isSkins = Button[i]
                                    if isSkins == true then
                                        isConstraints = false
                                        isPlayerFunctions = false
                                        isVehicleFunctions = false
                                    end
                                end
                            elseif dat == "player functions =>" then
                                if isPlayerFunctions == false then
                                    isPlayerFunctions = Button[i]
                                    if isPlayerFunctions == true then
                                        isConstraints = false
                                        isSkins = false
                                        isVehicleFunctions = false
                                    end
                                end
                            elseif dat == "vehicle functions =>" then
                                if isVehicleFunctions == false then
                                    isVehicleFunctions = Button[i]
                                    if isVehicleFunctions == true then
                                        isConstraints = false
                                        isSkins = false
                                        isPlayerFunctions = false
                                    end
                                end
                            end
                        else
                            render.setColor(Button[i] and BaseColor3 or BaseColor1)
                        end
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(string.match(dat, "=>", nil) and ConstraintsColor2 or BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, dat, 1)
                    end
                else
                    y = y + ButtonSize.y
                    render.setColor(BaseColor1)
                    render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                    render.setColor(BaseColor2)
                    render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                    render.setColor(Color(255, 255, 255, 255))
                    render.drawText(x + ButtonSize.x / 2, y + 5, "нет доступных функций", 1)
                end
                
                if isConstraints then
                    local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    local data = table.copy(DataConstraints)
                    for i = 1, table.count(data) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if dat != "" then
                            Button[100 + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        render.setColor(Button[100 + i] and BaseColor3 or BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[100 + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, dat, 1)
                    end
                elseif isSkins then
                    local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    local data = table.copy(DataSkins)
                    for i = 1, math.min(table.count(data), Ent:getSkinCount()) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if dat != "" then
                            Button[200 + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        render.setColor(Button[200 + i] and BaseColor3 or BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[200 + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, tonumber(dat:replace("skin ", "")) == Ent:getSkin() and " => " .. dat .. " <=" or dat, 1)
                    end
                elseif isPlayerFunctions then
                    local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    local data = table.copy(DataPlayerFunctions)
                    for i = 1, table.count(data) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if dat != "" then
                            Button[300 + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        render.setColor(Button[300 + i] and BaseColor3 or BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[300 + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, dat, 1)
                    end
                elseif isVehicleFunctions then
                    local x, y = ResX / 2 + 20 + ButtonSize.x, ResY / 2 - (ButtonSize.y * table.count(data) / 2)
                    local data = table.copy(DataVehicleFunctions)
                    for i = 1, table.count(data) do
                        local dat = data[table.getKeys(data)[i]]
                        y = y + ButtonSize.y
                        if dat != "" then
                            Button[400 + i] = Vector(mouseX, mouseY):withinAABox(Vector(x + ButtonCorrector, y + ButtonCorrector), Vector(x - ButtonCorrector, y - ButtonCorrector) + ButtonSize)
                        end
                        render.setColor(Button[400 + i] and BaseColor3 or BaseColor1)
                        render.drawRect(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(BaseColor2)
                        render.drawRectOutline(x, y, ButtonSize.x, ButtonSize.y)
                        render.setColor(Button[400 + i] and Color(0, 0, 0, 255) or Color(255, 255, 255, 255))
                        render.drawText(x + ButtonSize.x / 2, y + 5, dat, 1)
                    end
                end
            else
                Ent = nil
                input.enableCursor(false)
                closeTrees()
                Ply:emitSound("buttons/button8.wav", 75, 125, 0.75, CHAN_AUTO)
            end
        end
        
    end)
    
    function findTarget()
        local Angles = Ply:getEyeAngles()
        if Angles[1] == 89 and math.abs(Angles[3]) < 10 then
            Ent = owner()
            input.enableCursor(true)
            Ply:emitSound("buttons/button7.wav", 75, 125, 0.75, CHAN_AUTO)
        else
            if Ply:getEyeTrace().Entity:getClass() != "worldspawn" then
                Ent = Ply:getEyeTrace().Entity
                --print(Ply:getEyeTrace().Entity:getClass())
                input.enableCursor(true)
                Ply:emitSound("buttons/button7.wav", 75, 125, 0.75, CHAN_AUTO)
            end
        end
    end
    
    hook.add("inputPressed", "", function(key)
        if key == 108 and Ent == nil then
            if Ply:isValid() then
                if Ply:getActiveWeapon():isValid() then
                    if Ply:getActiveWeapon():getClass() == "weapon_empty_hands" then
                        findTarget()
                    end
                else
                    findTarget()
                end
            end
        elseif key == 108 and Ent != nil then
            Ent = nil
            input.enableCursor(false)
            Ply:emitSound("buttons/button7.wav", 75, 50, 0.75, CHAN_AUTO)
        elseif Ent != nil then
            if key == 107 then
                local data = getStorage()
                if (Ent:getSkinCount() or 0) > 1 then
                   table.insert(data, 1, "set skin =>") 
                end
                local mouseX, mouseY = input.getCursorPos()
                local isTrees = isConstraints or isSkins or isPlayerFunctions or isVehicleFunctions
                local inmenu = Vector(mouseX, mouseY):withinAABox(Vector(ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)), Vector(ResX / 2 + 20, ResY / 2 - (ButtonSize.y * table.count(data) / 2)) + Vector(ButtonSize.x * (isTrees and 2 or 1), 1000))
                if inmenu then
                    for i = 1, table.count(data) do
                        if Button[i] and not string.match(data[i], "=>", nil) then
                            net.start("sendFunc")
                            net.writeTable({id = Ent:entIndex(), func = data[i]})
                            net.send(Ply)
                            Ent = nil
                            input.enableCursor(false)
                            Ply:emitSound("buttons/button3.wav", 75, 125, 0.75, CHAN_AUTO)
                            closeTrees()
                        end
                    end
                    if isConstraints then
                        local data = table.copy(DataConstraints)
                        for i = 1, table.count(data) do
                            if Button[100 + i] then
                                net.start("sendFunc")
                                net.writeTable({id = Ent:entIndex(), func = data[i]})
                                net.send(Ply)
                                Ent = nil
                                input.enableCursor(false)
                                Ply:emitSound("buttons/button3.wav", 75, 125, 0.75, CHAN_AUTO)
                                closeTrees()
                            end
                        end
                    elseif isSkins then
                        local data = table.copy(DataSkins)
                        for i = 1, math.min(table.count(data), Ent:getSkinCount()) do
                            if Button[200 + i] then
                                net.start("sendFunc")
                                net.writeTable({id = Ent:entIndex(), func = data[i]})
                                net.send(Ply)
                                Ent = nil
                                input.enableCursor(false)
                                Ply:emitSound("buttons/button3.wav", 75, 125, 0.75, CHAN_AUTO)
                                closeTrees()
                            end
                        end
                    elseif isPlayerFunctions then
                        local data = table.copy(DataPlayerFunctions)
                        for i = 1, table.count(data) do
                            if Button[300 + i] then
                                net.start("sendFunc")
                                net.writeTable({id = Ent:entIndex(), func = data[i]})
                                net.send(Ply)
                                Ent = nil
                                input.enableCursor(false)
                                Ply:emitSound("buttons/button3.wav", 75, 125, 0.75, CHAN_AUTO)
                                closeTrees()
                            end
                        end
                    elseif isVehicleFunctions then
                        local data = table.copy(DataVehicleFunctions)
                        for i = 1, table.count(data) do
                            if Button[400 + i] then
                                net.start("sendFunc")
                                net.writeTable({id = Ent:entIndex(), func = data[i]})
                                net.send(Ply)
                                Ent = nil
                                input.enableCursor(false)
                                Ply:emitSound("buttons/button3.wav", 75, 125, 0.75, CHAN_AUTO)
                                closeTrees()
                            end
                        end
                    end
                else
                    Ent = nil
                    input.enableCursor(false)
                    closeTrees()
                    Ply:emitSound("buttons/button7.wav", 75, 50, 0.75, CHAN_AUTO)
                end
            end 
        end
    end)
    
end
